[{"body":"In addition to CMake and Git, which were discussed in this Page, the host, tag, and base software requires a number of tools and libraries. To compile the host tools, we require:\n A C++ compiler Python (version 3.7 or later) vcpkg – package management system (Windows only) homebrew – package management system (OS X only)  We also require the following libraries\n Google Protocol Buffers – libraries and compiler for google protocol buffers libusb – a library for interacting with USB devices Qt 5 – GUI interface libraries  Because we support compilation on three different types of systems, the installation process can be involved. The goal is to both install the tools and libraries, and to insure that CMake can find them during the build process. Furthermore, where possible, we would like to target static libraries in order to make distribution of the compiled software straightforward.\n1.1 C++ Compiler Linux Although many Linux distributions include C++, we also require some standard development tools in order to build the various libraries that we install. On Ubuntu systems the compiler and these tools can be installed from the command line:\n$ sudo apt update $ sudo apt-get install build-essential OS X The compilation tools we need are part of Xcode which is a free download. Once Xcode is installed, you need to enable the command line tools. In a terminal window (/Applications/Utilities/…):\nxcode-select -inst-all Windows Install the Visual Studio 19 Community Edition\n1.2 Python Install at least version 3.7.\n Linux Python3 OS X Python3 Windows Python3  1.3 vcpkg (Windows Only) Because Windows has a (very) broken method for managing paths to libraries and applications, we use the vcpkg manager for installing the various libraries that we require.\nChoose an appropriate location in which to install vcpkg, then, in a powershell window:\n$ git clone https://github.com/Microsoft/vcpkg.git $ ./vcpkg/bootstrap-vcpkg.sh Note you may need to add the path to git to your powershell environment, for example by adding\n$env:Path += \";PathToGit\" to the file $Home\\Documents\\PowerShell\\Profile.ps1.\n1.4 Homebrew (OS X only) Directions for installing homebrew are here\nThe basic approach is to execute the following in a terminal window:\n$ /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" 1.5 Protocol Buffers Google Protocol Buffers is a fundamental tool for both host and tag software as we use protocol files in the protocol buffer language to define host/tag communications.\nLinux $ apt install -y protobuf-compiler $ protoc --version # Ensure compiler version is 3+ OS X Install using home brew\n$ brew install protobuf $ protoc --version # Ensure compiler version is 3+ Windows On windows we use the vcpkg manager to handle the installation. In a powershell in the directory where you installed vcpkg, execute:\n$ .\\vcpkg install protobuf:x64-windows-static 3. Host Software Libraries Both host and embedded software require Google Protocol buffers. In addition, the host software requires Qt5 for graphical user interfaces and libusb to communicate with tag bases.\nOS X  qt5 – install with homebrew. libusb – install with homebrew.  Linux  qt5 – install libusb – sudo apt-get install libusb-dev  Windows Building large applications on Windows is challenging because of the lack of reasonable “path” mechanism allowing compilation tools to find the necessary libraries and because building portable applications requires “collecting” all of the necessary link libraries from the host OS. To solve the “path” problem, we utilize the vcpkg package manager and to solve the link library problem we utilize static builds of the necessary software libraries.\nInstructions for installing vcpkg manager can be found here. Once vckpg is installed you may install the necessary packages using the following command:\nvcpkg install [packages to install] You will need to install the following packages:\n protobuf:x64-windows-static qt5:x64-windows-static libusb:x64-windows-static angle:x64-windows-static  Notice that in each case we have selected the “static” version of the libraries. This ensures that the binaries that you build are portable across windows systems. The last of these packages (angle) provides openGL graphics compatibility.\n4. Embedded Tools  fmpp java gnuarm st programmer  ","categories":"","description":"","excerpt":"In addition to CMake and Git, which were discussed in this Page, the …","ref":"/docs/building/overview/","tags":"","title":"Software Tools/Libraries"},{"body":"General  CMake protobuf nanopb (submodule) QT5  Host  QT5 libusb  Embedded  ChibiOS – submodule branch 20.3.x GNU ARM embedded toolchain- https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm fmpp freemarker file preprocessor http://fmpp.sourceforge.net/ Make (install gnu make on windows) ST Cube Programmer https://www.st.com/en/development-tools/stm32cubeprog.html  Hardware  kicad 5 -https://www.kicad.org/ kibot https://github.com/skorokithakis/KiBot kiauto https://github.com/INTI-CMNB/KiAuto openscad  Windows  rc  Building on Linux Building on Windows Building on OS X ","categories":"","description":"","excerpt":"General  CMake protobuf nanopb (submodule) QT5  Host  QT5 libusb …","ref":"/docs/building/software/","tags":"","title":"Building Host Software"},{"body":"   Generic Tag Architecture   A high level view of the major components of a generic tag is illustrated above with optional sub-components indicated by dashed boxes. Every tag has an interface, a battery, a real-time clock (RTC), and a processor. In our tags we use the STM32L43x family of processors, which have extremely low-power “sleep” states, and one of several RTC chips – the RV-3028, RV-8803, and RV-3032. These RTC chips have exceptionally low energy requirements (40-240nA) and high accuracy (3-5ppm), and, for RV-8803 and RV-3032, temperature compensation.\nThe “always on” domain includes the core processor, the RTC, and any sensors or flash with sufficiently low quiescent current ($I_q$) to remain powered throughout the tag life. For example, the accelerometer used in BitTags and the LIS2DW12 accelerometer discussed in [custom tags] are both low $I_q$ with quiescent currents of 10nA(50nA), respectively. Some tags will have external flash and/or sensors with high quiescent current requiring load switches to disconnect them when idle. Both the LPS27 pressure sensor and the OPT3002 light sensors used in the custom tags discussed in the section on customization are high $I_q$ sensors with quiescent currents of 0.9uA (0.5uA), respectively. Similarly, while most external flash memory has high $I_q$, in our custom tags we use\na unique low $I_q$ flash – the AT25XE321, which can store 4mB data and operates over a wide voltage range.\nAs an example, consider the two sides of a BitTag stores activity bits/counts for up to 6675 hours (9 months) with a 5.5mAh battery. The energy performance of this tag is directly due to the ADXL362 accelerometer which has a hardware state machine for activity detection. When an “active” accelerometer observes acceleration below a programmed threshold for a programmed period, it enters a low energy “inactive” state in which it samples acceleration at 6Hz. When an “inactive” accelerometer detects acceleration above a programmed threshold, it wakes and samples at a higher rate. The BitTag firmware wakes the processor whenever the ADXL362 transitions between sleep and awake states in order to track the active periods.\nThe major components of a BitTag are the processor (STM32l432), RTC (RV-3028), and accelerometer (ADXL362).\n   Two sides of BitTag     The other major component of our hardware architecture is a base board (right) that provides software access to the tags through an ARM standard ‘‘serial wire debug’’ (SWD) interface. The tags are connected to the bases by an array of spring loaded ‘‘pogo-pins’’ (these contact the six test points illustrated in the tag photo above) and are supported by tag-specific 3D printed holders. In addition, our bases provide an external current measurement/voltage source interface to enable accurate dynamic current measurement during firmware development. The base hardware utilizes low-leakage analog switches to isolate the tag interface during current measurement. Finally, our tag bases include a battery charger that supports multiple batteries.\nWe program and communicate with our tags through the bases using existing open-source tools and libraries such as openocd and st-util. To accommodate these tools, our base firmware emulates the st-link protocol used by ST Microelectronics in their proprietary programmers.\n   Tag Base     ","categories":"","description":"","excerpt":"   Generic Tag Architecture   A high level view of the major …","ref":"/docs/architecture/hardware/","tags":"","title":"Hardware Architecture"},{"body":"For PCB design we use kicad and to automate the generation of gerber and outline files we use kibot.\nFor designing 3D base board adapters we use openscad\n","categories":"","description":"","excerpt":"For PCB design we use kicad and to automate the generation of gerber …","ref":"/docs/building/hardware/","tags":"","title":"Building Hardware"},{"body":"Use of Tags in Studying Bird Behavior  Pine Siskin with tagBen Vernasco\n  Tags have long been used for studies of animal behavior; however, the past decade has seen a “golden age” for tagging of smaller birds with the emergence of tags with a variety of sensors. Sensors include light used for geolocation (Citation: Bridge, Kelly. \u0026 al., 2013Bridge,  E.,  Kelly.,  J.,  Contina,  A.,  MacCurdy,  R.,  B,  a. \u0026 Winkler,  D.   (2013).  Advances in tracking small migratory birds: a technical review of light-level geolocation. Journal of Field Ornithology, 84(2). 121–137. https://doi.org/10.1111/jofo.12011 ) , (Citation: Fudickar, Wikelski \u0026 al., 2012Fudickar,  A.,  Wikelski,  M. \u0026 Partecke,  J.   (2012).  Tracking migratory songbirds: Accuracy of light-level loggers (geolocators) in forest habitats. Methods in Ecology and Evolution, 3(1). 47–52. https://doi.org/10.1111/j.2041-210X.2011.00136.x ) , accelerometers and barometers (Citation: Liechti, Bauer \u0026 al., 2018Liechti,  F.,  Bauer,  S.,  Dhanjal-Adams,  K.,  Emmenegger,  T.,  Zehtindjiev,  P. \u0026 Hahn,  S.   (2018).  Miniaturized multi-sensor loggers provide new insight into year-round flight behaviour of small trans-Sahara avian migrants. Movement Ecology, 6(1). 19–19. https://doi.org/10.1186/s40462-018-0137-1 ) , (Citation: Shipley, Kapoor \u0026 al., 2018Shipley,  J.,  Kapoor,  J.,  Winkler,  R. \u0026 W,  a.   (2018).  An open-source sensor-logger for recording vertical movement in free-living organisms. Methods in Ecology and Evolution, 9(3). 465–471. https://doi.org/10.1111/2041-210X.12893 ) , temperature (Citation: McCafferty, Gallon \u0026 al., 2015McCafferty,  D.,  Gallon,  S. \u0026 Nord,  A.   (2015).  Challenges of measuring body temperatures of free-ranging birds and mammals. Animal Biotelemetry, 3(1). 33–33. https://doi.org/10.1186/s40317-015-0075-2 ) , and even GPS (Citation: Lotek, Lotek (s.d.). Retrieved from  https://www.lotek.com/wp-content/uploads/2017/10/PinPoint-GPS-store-on-board-loggers-Spec-Sheet.pdf ) .\nFor small birds, such as the pine siskin illustrated to the right, the tags are attached to subject animals with a lightweight harness made from elastic thread. The tag rides under the bird’s feathers on its back and the harness loops under the bird’s legs. (Citation: Naef-Daenzer, Früh \u0026 al., 2005Naef-Daenzer,  B.,  Früh,  D.,  Stalder,  M.,  Wetli,  P. \u0026 Weise,  E.   (2005).  Miniaturization (0.2 g) and evaluation of attachment techniques of telemetry transmitters. Journal of Experimental Biology, 208(21). 4063–4068. https://doi.org/10.1242/jeb.01870 ) (Citation: Rappole \u0026 Tipton, 1991Rappole,  J. \u0026 Tipton,  A.   (1991).  New harness design for attachment of radio transmitters to small passerines. Journal of field ornithology, 62(3). 335–337. ) Many of the early studies utilizing sensing tags focused upon data from accelerometers which can be used to determine when animals are active and, to a degree, the type of their activity (e.g. flight). (Citation: Bäckman, Andersson \u0026 al., 2017Bäckman,  J.,  Andersson,  A.,  Alerstam,  T.,  Pedersen,  L.,  Sjöberg,  S.,  Thorup,  K. \u0026 Tøttrup,  A.   (2017).  Activity and migratory flights of individual free-flying songbirds throughout the annual cycle: method and first case study. Journal of Avian Biology, 48(2). 309–319. https://doi.org/10.1111/jav.01068 ) , (Citation: Brown, Kays \u0026 al., 2013Brown,  D.,  Kays,  R.,  Wikelski,  M.,  Wilson,  R. \u0026 Klimley,  A.   (2013).  Observing the unwatchable through acceleration logging of animal behavior. Animal Biotelemetry, 1(1). 20–20. https://doi.org/10.1186/2050-3385-1-20 ) , (Citation: Collins, Green \u0026 al., 2015Collins,  P.,  Green,  J.,  Warwick-Evans,  V.,  Dodd,  S.,  Shaw,  P.,  Arnould,  J. \u0026 Halsey,  L.   (2015).  Interpreting behaviors from accelerometry: A method combining simplicity and objectivity. Ecology and Evolution, 5(20). 4642–4654. https://doi.org/10.1002/ece3.1660 ) . Accelerometers have led to some notable discoveries the extended aerial life of swifts. (Citation: Hedenström, Norevik \u0026 al., 2016Hedenström,  A.,  Norevik,  G.,  Warfvinge,  K.,  Andersson,  A.,  Bäckman,  J. \u0026 Åkesson,  S.   (2016).  Annual 10-Month Aerial Life Phase in the Common Swift Apus apus. Current Biology, 26(22). 3066–3070. https://doi.org/10.1016/j.cub.2016.09.014 ) , (Citation: Liechti, Witvliet \u0026 al., 2013Liechti,  F.,  Witvliet,  W.,  Weber,  R. \u0026 Bächler,  E.   (2013).  First evidence of a 200-day non-stop flight in a bird. Nature Communications, 4(1). 2554–2554. https://doi.org/10.1038/ncomms3554 ) Pressure sensors have been shown to have great utility in understanding the behavior of birds during migration. For example, (Citation: Dhanjal-Adams, Bauer \u0026 al., 2018Dhanjal-Adams,  K.,  Bauer,  S.,  Emmenegger,  T.,  Hahn,  S.,  Lisovski,  S. \u0026 Liechti,  F.   (2018).  Spatiotemporal Group Dynamics in a Long-Distance Migratory Bird. Current Biology, 28(17). 2824–2830.e3. https://doi.org/10.1016/j.cub.2018.06.054 ) demonstrated that by comparing pressure measurements over time it is feasible to determine which animals from a given site migrate together, (Citation: Liechti, Bauer \u0026 al., 2018Liechti,  F.,  Bauer,  S.,  Dhanjal-Adams,  K.,  Emmenegger,  T.,  Zehtindjiev,  P. \u0026 Hahn,  S.   (2018).  Miniaturized multi-sensor loggers provide new insight into year-round flight behaviour of small trans-Sahara avian migrants. Movement Ecology, 6(1). 19–19. https://doi.org/10.1186/s40462-018-0137-1 ) demonstrated that one can reliably use pressure measurements to determine when animals are migrating, and (Citation: Sjöberg, Malmiga \u0026 al., 2021Sjöberg,  S.,  Malmiga,  G.,  Nord,  A.,  Andersson,  A.,  Bäckman,  J.,  Tarka,  M.,  Willemoes,  M.,  Thorup,  K.,  Hansson,  B.,  Alerstam,  T. \u0026 Hasselquist,  D.   (2021).  Extreme altitudes during diurnal flights in a nocturnal songbird migrant. Science, 372(6542). 646–648. https://doi.org/10.1126/science.abe7291 ) determined that small animals may fly above 5000 meters during migration.\nThe Problem  (kays2015s)\n  Tag mass is limited by the species being studied. The adjacent figure illustrates the distribution of mass for bird species. (Citation: Kays, Crofoot \u0026 al., 2015Kays,  R.,  Crofoot,  M.,  Jetz,  W. \u0026 Wikelski,  M.   (2015).  Terrestrial animal tracking as an eye on life and planet. Science, 348(6240). aaa2478–aaa2478. https://doi.org/10.1126/science.aaa2478 ) The data for this figure were drawn from sources such as (Citation: Blackburn \u0026 Gaston, 1994Blackburn,  T. \u0026 Gaston,  K.   (1994).  The Distribution of Body Sizes of the World’s Bird Species. Oikos, 70(1). 127–127. https://doi.org/10.2307/3545707 ) and (Citation: Dunning, 2007Dunning,  J.  (2007).  CRC handbook of avian body masses, second edition ().   CRC Press. https://doi.org/10.1201/9781420064452 ) . Among North American birds, 12% of species are $20-30g$ and 27% of species are $10-20g$.\nWhile there are no fixed limits on allowable tag mass, previous studies have limited them to 3-5% of body mass (e.g. (Citation: Kenward, 2001Kenward,  R.  (2001).  A Manual for Wildlife Radio Tracking.   Academic Press. ) ) with 3-4% becoming a common restriction. With these tighter limits, animals in the range $10-30g$ can only be studied with tags in the ranges of $0.3-0.9g$ to $0.4-1.2g$, respectively. There have been a number of studies that attempt to assess the impact of tag mass on animal survival and breeding (for example, (Citation: Atema, Van Noordwijk \u0026 al., 2016Atema,  E.,  Van Noordwijk,  A.,  Boonekamp,  J. \u0026 Verhulst,  S.   (2016).  Costs of long-term carrying of extra mass in a songbird. Behavioral Ecology, 27(4). 1087–1096. https://doi.org/10.1093/beheco/arw019 ) , (Citation: Bell, El Harouchi \u0026 al., 2017Bell,  S.,  El Harouchi,  M.,  Hewson,  C. \u0026 Burgess,  M.   (2017).  No short- or long-term effects of geolocator attachment detected in Pied Flycatchers Ficedula hypoleuca. Ibis, 159(4). 734–743. https://doi.org/10.1111/ibi.12493 ) )\nA large fraction of tag weight is dedicated to energy storage and a large portion of the design effort for a tag is dedicated to energy efficiency. The tags described in this website utilize rechargeable lithium manganese batteries. Three such batteries are presented in Table 1. Notice that the capacity of all three (at $2.5V$) is roughly $225J/g$. This is similar to other rechargeable battery chemistries.\nTable 1: Seiko MS Series Batteries (Citation: , 2021(2021). Retrieved from  http://www.sii.co.jp/en/ )     Type Size (DxH) mm Mass ($g$) Capacity ($mAh$) Capacity ($J$)     MS518SE 5.8x1.8 0.13 3.4 30.6   MS621FE 6.8x2.1 0.23 5.5 49.5   MS920SE 9.5x2.1 0.47 11 99    The BitTags described in this site range from $0.45-0.85g$ with the three different batteries shown in Table 1.\nAt the scale of the tags we describe, energy harvesting is not currently practical. The additional weight of the energy harvesting components and energy conversion electronics would be significant.\nThis Project We present an activity monitor, BitTag, that can continuously collect data for 4-12 months at $0.5-0.8g$, depending upon battery choice, and which has been used to collect more than 200,000 hours of data in a variety of experiments.\nThe BitTag architecture provides a general platform to support the development and deployment of custom sub-$g$ tags. This platform consists of a flexible tag architecture, software for both tags and host computers, and hardware to provide the host/tag interface necessary for preparing tags for “flight” and for accessing data “post-flight”.\nWe present designs for custom tags with a variety of sensors and a process for developing them that utilizes a purpose-built development platform with off-the-shelf sensor evaluation boards to enable both accurate energy and power measurements as well as supporting software development. The host/tag software architecture, built using Google protocol buffers, makes it straightforward to extend host and tag software to support new tags with backward compatibility.\nThe host hardware – to program, configure, and charge tags – is designed to support a variety of batteries and to enable new tags, with different physical outlines, to be supported simply by creating a new 3d-printed adapter.\nAcknowledgement This material is based upon work supported by the National Science Foundation Grant Number 1644717. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation.\nReferences   Atema,  Van Noordwijk,  Boonekamp \u0026 Verhulst (2016)  Atema,  E.,  Van Noordwijk,  A.,  Boonekamp,  J. \u0026 Verhulst,  S.   (2016).  Costs of long-term carrying of extra mass in a songbird. Behavioral Ecology, 27(4). 1087–1096. https://doi.org/10.1093/beheco/arw019    Bäckman,  Andersson,  Alerstam,  Pedersen,  Sjöberg,  Thorup \u0026 Tøttrup (2017)  Bäckman,  J.,  Andersson,  A.,  Alerstam,  T.,  Pedersen,  L.,  Sjöberg,  S.,  Thorup,  K. \u0026 Tøttrup,  A.   (2017).  Activity and migratory flights of individual free-flying songbirds throughout the annual cycle: method and first case study. Journal of Avian Biology, 48(2). 309–319. https://doi.org/10.1111/jav.01068    Bell,  El Harouchi,  Hewson \u0026 Burgess (2017)  Bell,  S.,  El Harouchi,  M.,  Hewson,  C. \u0026 Burgess,  M.   (2017).  No short- or long-term effects of geolocator attachment detected in Pied Flycatchers Ficedula hypoleuca. Ibis, 159(4). 734–743. https://doi.org/10.1111/ibi.12493    Blackburn \u0026 Gaston (1994)  Blackburn,  T. \u0026 Gaston,  K.   (1994).  The Distribution of Body Sizes of the World’s Bird Species. Oikos, 70(1). 127–127. https://doi.org/10.2307/3545707    Bridge,  Kelly.,  Contina,  MacCurdy,  B \u0026 Winkler (2013)  Bridge,  E.,  Kelly.,  J.,  Contina,  A.,  MacCurdy,  R.,  B,  a. \u0026 Winkler,  D.   (2013).  Advances in tracking small migratory birds: a technical review of light-level geolocation. Journal of Field Ornithology, 84(2). 121–137. https://doi.org/10.1111/jofo.12011    Brown,  Kays,  Wikelski,  Wilson \u0026 Klimley (2013)  Brown,  D.,  Kays,  R.,  Wikelski,  M.,  Wilson,  R. \u0026 Klimley,  A.   (2013).  Observing the unwatchable through acceleration logging of animal behavior. Animal Biotelemetry, 1(1). 20–20. https://doi.org/10.1186/2050-3385-1-20    Collins,  Green,  Warwick-Evans,  Dodd,  Shaw,  Arnould \u0026 Halsey (2015)  Collins,  P.,  Green,  J.,  Warwick-Evans,  V.,  Dodd,  S.,  Shaw,  P.,  Arnould,  J. \u0026 Halsey,  L.   (2015).  Interpreting behaviors from accelerometry: A method combining simplicity and objectivity. Ecology and Evolution, 5(20). 4642–4654. https://doi.org/10.1002/ece3.1660    Dhanjal-Adams,  Bauer,  Emmenegger,  Hahn,  Lisovski \u0026 Liechti (2018)  Dhanjal-Adams,  K.,  Bauer,  S.,  Emmenegger,  T.,  Hahn,  S.,  Lisovski,  S. \u0026 Liechti,  F.   (2018).  Spatiotemporal Group Dynamics in a Long-Distance Migratory Bird. Current Biology, 28(17). 2824–2830.e3. https://doi.org/10.1016/j.cub.2018.06.054    Dunning (2007)  Dunning,  J.  (2007).  CRC handbook of avian body masses, second edition ().   CRC Press. https://doi.org/10.1201/9781420064452    Fudickar,  Wikelski \u0026 Partecke (2012)  Fudickar,  A.,  Wikelski,  M. \u0026 Partecke,  J.   (2012).  Tracking migratory songbirds: Accuracy of light-level loggers (geolocators) in forest habitats. Methods in Ecology and Evolution, 3(1). 47–52. https://doi.org/10.1111/j.2041-210X.2011.00136.x    Hedenström,  Norevik,  Warfvinge,  Andersson,  Bäckman \u0026 Åkesson (2016)  Hedenström,  A.,  Norevik,  G.,  Warfvinge,  K.,  Andersson,  A.,  Bäckman,  J. \u0026 Åkesson,  S.   (2016).  Annual 10-Month Aerial Life Phase in the Common Swift Apus apus. Current Biology, 26(22). 3066–3070. https://doi.org/10.1016/j.cub.2016.09.014    Kays,  Crofoot,  Jetz \u0026 Wikelski (2015)  Kays,  R.,  Crofoot,  M.,  Jetz,  W. \u0026 Wikelski,  M.   (2015).  Terrestrial animal tracking as an eye on life and planet. Science, 348(6240). aaa2478–aaa2478. https://doi.org/10.1126/science.aaa2478    Kenward (2001)  Kenward,  R.  (2001).  A Manual for Wildlife Radio Tracking.   Academic Press.    Liechti,  Witvliet,  Weber \u0026 Bächler (2013)  Liechti,  F.,  Witvliet,  W.,  Weber,  R. \u0026 Bächler,  E.   (2013).  First evidence of a 200-day non-stop flight in a bird. Nature Communications, 4(1). 2554–2554. https://doi.org/10.1038/ncomms3554    Liechti,  Bauer,  Dhanjal-Adams,  Emmenegger,  Zehtindjiev \u0026 Hahn (2018)  Liechti,  F.,  Bauer,  S.,  Dhanjal-Adams,  K.,  Emmenegger,  T.,  Zehtindjiev,  P. \u0026 Hahn,  S.   (2018).  Miniaturized multi-sensor loggers provide new insight into year-round flight behaviour of small trans-Sahara avian migrants. Movement Ecology, 6(1). 19–19. https://doi.org/10.1186/s40462-018-0137-1    Lotek (n.d.)  Lotek (s.d.). Retrieved from  https://www.lotek.com/wp-content/uploads/2017/10/PinPoint-GPS-store-on-board-loggers-Spec-Sheet.pdf    McCafferty,  Gallon \u0026 Nord (2015)  McCafferty,  D.,  Gallon,  S. \u0026 Nord,  A.   (2015).  Challenges of measuring body temperatures of free-ranging birds and mammals. Animal Biotelemetry, 3(1). 33–33. https://doi.org/10.1186/s40317-015-0075-2    Naef-Daenzer,  Früh,  Stalder,  Wetli \u0026 Weise (2005)  Naef-Daenzer,  B.,  Früh,  D.,  Stalder,  M.,  Wetli,  P. \u0026 Weise,  E.   (2005).  Miniaturization (0.2 g) and evaluation of attachment techniques of telemetry transmitters. Journal of Experimental Biology, 208(21). 4063–4068. https://doi.org/10.1242/jeb.01870    Rappole \u0026 Tipton (1991)  Rappole,  J. \u0026 Tipton,  A.   (1991).  New harness design for attachment of radio transmitters to small passerines. Journal of field ornithology, 62(3). 335–337.    Shipley,  Kapoor,  Winkler \u0026 W (2018)  Shipley,  J.,  Kapoor,  J.,  Winkler,  R. \u0026 W,  a.   (2018).  An open-source sensor-logger for recording vertical movement in free-living organisms. Methods in Ecology and Evolution, 9(3). 465–471. https://doi.org/10.1111/2041-210X.12893    (2021)  (2021). Retrieved from  http://www.sii.co.jp/en/    Sjöberg,  Malmiga,  Nord,  Andersson,  Bäckman,  Tarka,  Willemoes,  Thorup,  Hansson,  Alerstam \u0026 Hasselquist (2021)  Sjöberg,  S.,  Malmiga,  G.,  Nord,  A.,  Andersson,  A.,  Bäckman,  J.,  Tarka,  M.,  Willemoes,  M.,  Thorup,  K.,  Hansson,  B.,  Alerstam,  T. \u0026 Hasselquist,  D.   (2021).  Extreme altitudes during diurnal flights in a nocturnal songbird migrant. Science, 372(6542). 646–648. https://doi.org/10.1126/science.abe7291     ","categories":"","description":"","excerpt":"Use of Tags in Studying Bird Behavior  Pine Siskin with tagBen …","ref":"/background/","tags":"","title":"Background"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/","tags":"","title":"Documentation"},{"body":"Preparing BitTags for flight requires the following steps:\n Charging – be prepared to charge each tag for at least 2 days Configuring – the data collection protocol including start/end times, hibernation periods, and sensor parameters. Insulating – after configuration the test points should be immediately covered with insulating tape Harness attachment  In this guide we discuss 1-3. Note some of the photos were made with earlier versions of the tags and tag bases; however, the principles remain the same.\nVisual Glossary Bit Tags Ultra-low power reusable accelerometer loggers, capable of logging activity up to a year     Charger Bases Charges Bit Tag batteries and displays battery charge status.    Programmer Base  Allows data transfer between Bit Tags and computer, for configuration and data downloading  Mini-USB Cable Delivers power and data to Bit Tag chargers and programming base.    Insulating Tape (3mm Kapton) Protects Bit Tag contacts from short-circuits.    Tape Application Sticks (4mm width) Flat wooden sticks, commonly used as coffee stirrers. Useful for applying tape to Bit Tags, and for measuring tape length.    Harness Material Elastic sewing thread. May also be available through dental supply houses.    Scissors For cutting tape and harness material. The smaller the better.    Monitor Program Configures and downloads data from BitTag    btviz Program Displays data and generates actograms.    BitTags     Specifications   Weight (Without Harness) 0.64g\n  Dimensions 22Lx9Wx6H mm\n  Run Time (Depends on mode, limited by battery size)\n  Bits Per Second 239 hours (~10 days)\n  Counts per Minute 2395 hours (~100 days)\n  Counts per 4 Minutes 9900 hours (~414 days)\n  Counts per 5 Minutes 8700 hours (~362 days)\n    Battery Capacity 5.5 mAh\n  Average Current Consumption \u003c 1uA\n  CPU STM32L432KC\n  Accelerometer ADXL362\n  Clock Accuracy ±3ppm\n  Pre-Flight 1. Charge Bit Tags Plug in Charger Base and ensure it is receiving power. A green light will illuminate on the Charger Base that is plugged in. All other Charger Bases can then share power from this Charger Base.    Remove nuts and lid from Charger Base    Place Bit Tag in the plastic holder, ensuring it seats fully.    Place lid on base, aligning dots.    Gently tighten nuts with one finger, to avoid damaging delicate electronics.     Check to make sure BitTag makes contact with charger. Bit Tags typically take 48-27 hours to charge. Charging is Not complete when the battery indicator turns from red to green. To fully charge, batteries must be held at their charge voltage for 24-48 hours.       Remove Bit Tags when done charging. Unused Bit Tags can store for 1-2 months before needing to be recharged.\n  To remove, reverse the installation process.\n  2. Configure Bit Tags Note: Images in this section need updating for newer software\nPlace Bit Tag in Programmer Base, following the same procedure as installing Bit Tags into chargers. Note: Programmer Base must be plugged into computer before receiving a Bit Tag.     Open the monitor program. Click “Attach” Check that battery voltage is 3.0 volts or greater. If not, detach and recharge. While still functional, battery voltage below 3.0 volts will result in suboptimal runtimes.      If Bit Tag is in a state other than “IDLE”, you may need to “Stop” and then “Erase” Bit Tag.      Once the tag is in the “idle” state, run the internal tests (“Test”) and then synchronize the clock “Sync”. If any tests fail, you should not use the tag.      Click into the “Configure” tab. Schedule BitTag Data Collection      Select Data Type Log Format based upon experiment requirements  Activity Bit Per Second: Gives second-by-second log of whether or not the animal is active. Highest resolution data. Run Time of around 10 days. Activity Bit Count Per Minute: Records the percentage of each minute the animal was active. Run Time of around 100 days. Activity Bit Count Per Four/Five Minutes: Same as Activity Bit Count Per Minute, but over four or five minute intervals. Lowest resolution, but allows Run Time of around 365 days.       Click “Run” to save settings and start Bit Tag.    Return to the “Tag State” tab. Ensure that the Bit Tag is in the “CONFIGURED” or “RUNNING” state. If not, check your configuration and click “Run” again.    Click “Detach” and remove BitTag from base.    3. Insulate Bit Tags Cut a short strip of Insulating Tape just long enough to fully cover contacts (about 4mm - or the width of tape application sticks) on the back of Bit Tag.    Place tape partially on Tape Application Stick (leaving ~2mm overhang lengthwise) and gently stick one edge onto Bit Tag    Press stick firmly onto tape and “squeegee” out any air bubbles or pockets. Tape should sit flat on surface of Bit Tag.    4 Build Harnesses See section ???\nBit Tags can be attached via harness using the four mounting holes (1mm diameter). For songbird, the size of the leg-loop harness can be estimated using the function described by Naef-Daenzer (2007, J. Avian Biology, 38: 404-407)    Post-Processing 1 Recovery Remove harnesses and insulating tape, being careful not to contact the Bit Tag with sharp or metallic tools. The Tape Application Stick can also be used to gently peel up the tape.     Place Bit Tag into Programmer Base.  Note: Ensure Programmer Base is plugged into the computer first.   Open the monitor program and attach.     Stop the BitTag.     Save data. Important: Save your data as a “.txt” file.  Note: The data length may sometimes show up as zero, even if there is saved data onboard.   Detach the BitTag and remove from base.     2 Data Visualization See Section ???\n  Open btviz\n  To import data click ‘load’ and select data file (data file should have a .txt extension)\n     If you need to trim your data, enter Start and End times then click “Zoom”    You may also use your mouse to visually select these times:\n  Double-click on the chart with the Left Mouse Button to set the Start time (One-finger double-click on Mac).\n  Double-click on the chart with the Right Mouse Button to set the End time (Double-click with two fingers, or while holding Control (⌃) on Mac).\n  Click “Zoom”\n     You may export your data in a variety of formats:\n PDF/PNG: Saves the currently displayed figure as an image CSV: Saves all data currently visible in the image as a .csv file of data points.     You may also view and save actograms by clicking on the ‘actogram’ tab at the top.    ","categories":"","description":"Preparing tags for flight\n","excerpt":"Preparing tags for flight\n","ref":"/docs/userguides/preflight/","tags":"","title":"Preparing for Flight"},{"body":"The BitTag is a novel data logger capable of collecting continuous activity data for 360 days – depending upon battery size. The operational concept is simple – BitTag contains an accelerometer that detects movement and, based upon the movement dynamics, determines if the subject animal is active. Each second BitTag generates a single bit of information – 1 if the animal is active, 0 if it is it is not. These bits are aggregated (counted) over a measurement period 1 second to 5 minutes; at the end of each aggregation period the counts are stored in non-volatile memory. The choice of aggregation period depends upon the length of the experiment and is constrained by the amount of available storage – 248 hours for raw data to 8660 hours for 5 minute aggregation. In section ?? we present the design of a new BitTag with external memory capable of storing 8738 hours of data aggregated over 15 seconds.\nBitTag has been used in a variety of experiments with both captive and free animals including monitoring circadian rhythms, determining changes in activity around migration and egg laying, and when migrating animals fly.\n   The key component in the BitTag is a extremely low energy accelerometer – the adxl362. This accelerometer has special activity detection hardware that samples current acceleration along 3-axes at 6hz. When an animal is completely still there is 1g acceleration towards the earth due to gravity. In activity detection mode, the adxl362 tracks acceleration – when the change in acceleration is greater than a configured threshold, the device signals the BitTag processor that the animal is active. When the acceleration remains within a configured range for a configured time, the BitTag signals that the animal is inactive.\nThe detection algorithm is illustrated to the right. Consider a tag with two states – inactive and active. An inactive tag (a) remains inactive until it experiences acceleration greater than the “active threshold” (b). An active tag remains active until it remains within a configured acceleration range for a configured time (d). Notice that whenever an active tag exceeds the configured threshold, the center of the range moves (c-d). This tracking hardware is remarkably low energy (300nA), but very effective at tracking bird activity because flying naturally results in high acceleration changes.\n   As an example of the type of data that BitTag collects consider the figure on the right which was created with the BitTag visualization tool btviz. The data illustrate several days during the migration of a Robin and clearly illustrates a long flight on November 12 with several shorter flights. Migration during this period was confirmed with an attached GPS data logger. (Figure courtesy of Alex Jahn)\nThe figure is a screen shot of our visualization tool which enables data exploration by zooming, scrolling, and low-pass filtering. Additional overlay graphs are available to display the tag battery voltage and temperature. The former is useful for evaluating the battery discharge rate in long experiments.\n   Robin Migration     A common way for behavioral scientists to explore activity data is through an “actogram”. The actogram is organized to display multiple 48-hour periods (two days in a row), with rows beginning on successive days. Thus every 24-hour period is displayed twice – first in the left column and then in the right column. Our visualization tool provides ways to customize the view including the number of rows, data scalling, and offset from UTC time. Another feature, not displayed here, is the ability to overlay the sun angle based upon a specific location or a simulation model for indoor studies.    BitTag Actogram     Tag Infrastructure The physical design of tags is just a small part of the system design problem. To be useful, the tags require a support “ecosystem” that enables tag configuration, battery charging, and data recovery. This ecosystem includes both software (tag firmware, configuration software, data processing), and support hardware. For example, we have developed a “standard” hardware base to which tags are attached for configuration and charging. Variations in battery chemistry necessitate (small) hardware differences in the bases – we use two distinct types of batteries NiMn and LiPo. Furtunately, these hardware differences are opaque to the system software.\nOf course different tags will have variations in geometry, thus our base architecture includes a 3D printed adapter that is tag specific. The adjacent image illustrates one such adapter along with the hand tools used to finish the commercially printed component. The tags carry a small array of “test points” (covered with insulation during flight) through which all base/tag communication occurs. The mechanical issues of reliably connecting to the tags are considerable and are discussed in [link].\nIt is worth noting that we face a scale problem – supporting experiments with dozens of tags is considerably different than configuring and testing single tags. For example, consider that our partners need to prepare groups of 20-100 tags for flight simultaneously. Simply charging the tag batteries takes many hours (e.g. overnight), thus we have also developed chargers that can be “ganged” together and connected by a single USB connection.\nThe adjacent image illustrates three such chargers (only one USB connector is used per ‘gang’). These chargers can be built relatively inexpensively (under $50/each in small quantities).\n   Programmer for BitTags     Tagbase Adapter and Tools     Tag Charger Array     Tag Configuration The tags that we build are highly configurable. For example, the BitTags can be configured with various “thresholds” for determining when the animal is active, different data aggregation choices (from 1 bit/second to active second counts per 5-minutes), and complex schedules including hibernation periods.\nThe primary tool that we have developed for configuring tags is the “Avian Tag Monitor”. This tool organizes Tag information as a set of tabs. The first tab, illustrated on the right, provides information about the specific tag including its current state, battery voltage, and clock error as well as details about the hardware and software on the tag.\nThis tab also provides various control actions and provides for data download.    NanoLogger Monitor     As mentioned, the tags provide the ability to create complex schedules including start and end times for data collection as well as “hibernation periods” when data collection should be suspended.    NanoLogger Monitor     Modern sensors provide many possible configuration options. For the BitTag, the accelerometer can be configured with various scales, sample rates, and thresholds for activity detection.\nThe Tag Monitor provides access to these configuration options.    NanoLogger Monitor     The Tag Monitor software is highly configurable and is designed so that it can be extended to support additional types of sensors and data storage strategies. The specific options shown are automatically customized to the tag being configured. In addition, we provide support for batch testing and configuration of tags through separate command-line tools.\n","categories":"","description":"","excerpt":"The BitTag is a novel data logger capable of collecting continuous …","ref":"/docs/bittag/","tags":"","title":"BitTag"},{"body":"This section provides the following user guides.\n","categories":"","description":"Instructions for using and configuring tags\n","excerpt":"Instructions for using and configuring tags\n","ref":"/docs/userguides/","tags":"","title":"User Guides"},{"body":"The system software for NanoTags consists of firmware (the software running on the tags), a host library supporting communication with tags that are connected through a base, and various host applications utilizing this library including a configuration GUI, and command-line tools for testing and commissioning tags. Additionally, we have developed a data analysis tool for BitTags which we will not discuss in this section.\nOur goal in developing this system software was to create an architecture that can “grow” with the addition of new types of tags and the creation of specialized firmware to support specific experiments. At the heart of our architecture is communication and data transfer (definition) through Google Protocol Buffers. The fundamental idea of Protocol Buffers is to provide a language for describing data (messages) and a standard way to encode these data in a binary serial form. The message (data) definitions then form the interface between communicating systems – in this case tags and system software. In practice, protocol buffers provides much more in the form of tools that enable their use with a wide variety of languages including compilation of message definitions into language specific libraries. Protocol Buffers have efficient support for use in embedded code through the nanopb tools.\nThe use of protocol buffers greatly simplifies the problem of providing a coherent and extensible interface between tags and hosts. By compiling from common source – the message definitions – all aspects of shared data are kept coordinated. Further, Protocol Buffers provides a standard way to extend the message definitions without breaking backwards compatability. Thus, we can add support for new tags by extending the message definitions (for example to support new sensor types), and extend the host tools to utilize these new definitions without “breaking” support for existing tags. This is particularly important where tags “in flight” may be in use for many months.\nArchitecture We begin by presenting an abstract model of the tag “life cycle” which describes the execution of an arbitrary tag. This tag lifecycle will serve to motivate the interface to the host library used by our host applications; we will demonstrate this library with a simple application that sets the real-time clock on an arbitrary tag. We then discuss how the methods of this host interface library are realized with Protocol Buffer based RPC and finally discuss the tag firmware.\nTag   Tag Lifecycle   Consider the life cycle of a tag. which corresponds directly to the runtime state machine. Notice that there are three categories of states - Erased, Active, and Completed. In the Erased states, no data or configuration is stored in non-volatile memory. The Active states correspond to a tag that is configured or is actively collecting data. In these states, configuration, and event and data logs are stored in non-volatile memory. Finally, the Completed states are post-experiment in the sense that data collection has ceased by design, by external command, or through an unrecoverable error (e.g. power brown-out). In the Completed states, the event and data logs from the last Active period are preserved in non-volatile memory.\nIn addition to organization by groups of states, our figure distinguishes between three types of state transitions. Internal transitions are shown as dashed arrows, transitions in response to an external command are shown as solid arrows, and the transition after commissioning is shown as a double arrow.\nThe initial state after commissioning and erasure is Idle. From Idle various tag-specific tests can be executed under host control. When a test is initiated, that tag enters the Test state; once the test is completed, the tag returns to the Idle state. Test results are stored in volatile memory.\nAn experiment (biological or development) is initiated by the host from Idle, by configuring the tag with a Start(config) command. The tag configuration includes stop and end times, hibernation periods (when no data are collected), and, tag-specific parameters for sensors and data collection.\nFrom the Configured state the tag enters the Running state once the configured start time (Config.start) has been reached. In Running the tag actively collects data; a tag may hibernate (2) for a configured hibernation period during which all data collection ceases. The fundamental difference between Hibernation and Running is that in the former, all sensors are powered down and the tag enters the lowest possible energy (dormant) state while in the later the tag is either quiescent (waiting for an event) or the processor is actively running.\nUnder ordinary conditions, a tag remains active until an end condition is met. This can be a configured end time, exhaustion of available data storage, or exhaustion of available energy. In each of these cases, the tag will enter Finish. In the occurrence of an unplanned (1) event, for example a power brown-out, all of the active states will transition to Aborted.\nThe tag is returned from a completed state to Idle via an external Erase() command; the intermediate Reset manages the erasure of the non-volatile storage.\nHost The host software consists of a code library that provides a procedural interface to a tag, and applications that use this library. These applications include a graphical user interface intended to be used by researchers who need to configure tags and download collected data, and command-line applications that can be used to test tags and configure them from stored configuration files. The host library is written in C++ an provides a tag object model that allows software to use a procedural interface for tag access.\nConsider again the state diagram describing the tag “lifecycle” and notice the state transitions labeled Test(), Start(config), Stop(), and Erase(). These correspond directly to methods of the tag class.\nThe Start() command takes a configuration object as a parameter. In execution, this configuration object (a Protocol Buffer message) is transferred to the tag; when the tag evaluates the Start command, it records the configuration and enters the Configurated state. It is possible to abort execution of a tag by issuing a Stop() command.\nA tag may have its data erased with the Erase() command. Finally, all tags have some built-in test functions. The test sequence is initiated with the Test() command and test status (including failures) returned as a string with the GetStatus() command.\n bool Start(Config \u0026config); bool Stop(); bool Test(TestReq test); bool Erase(); bool GetStatus(Status \u0026status); bool GetConfig(Config \u0026cfg); bool SetRtc();    Because the tag software architecture can support a variety of tag types, it is important that the application support a degree of introspection. This allows the software to determine the type of the tag, significant aspects of the tag software that admit tracing back to the github repository from which the software was built, and the tag processor’s unique identifier (UUID).  struct TagInfo { TagType tag_type; // tag type  std::string board_desc; // board description  std::string uuid; // processor unique id  int64 intflashsz; // internal flash size (bytes)  int64 extflashsz; // external flash size (bytes)  // software  std::string firmware; // firmware description  std::string gitrepo; // git repo  std::string githash; // git version hash  std::string source_path; // path to source in repo  std::string build_time; // build time  }; bool GetTagInfo(TagInfo \u0026info);    Finally, the tag library provides methods for downloading data and state logs. During execution, the tag records each of the system states that it executes (Configured, Running, etc.) along with key state information such as the time the state was entered, the amount of data recorded, etc. This system log is accessed through a method that returns this sequence of recorded states.\nbool GetSystemLog(std::vector\u003cState\u003e \u0026system_log); The type(s) of data recorded by various tags depends upon the sensors on the tag and the tag configuration. This variation is handled by returning the protocol buffer acknowledgement message to be decoded by a separate library which converts data messages to human readable form\nbool GetDataLog(Ack \u0026data_log, int index); The amount of data returned by a single execution of this method is implementation specific; the index parameter indicates the starting point for the next block of data to be returned.\nFinally, the tag library provides methods to connect and disconnect from tags.\nbool Attach(UsbDev usbdev = UsbDev()); bool Detach(); bool IsAttached(); From the perspective of host software, a tag appears as a USB device (a base) to which the host software attaches and detaches. The optional parameters of the Attach method allow selecting a specific device.\nAn Example We exploit this interface both for a GUI based tool that we provide to biologists and for command-line tools to test and commission tags. The following example illustrates the simplicity of this interface for creating custom command-line tools – in this case to set and check the RTC for short term drift. This is one of the steps performed in the commissioning process to ensure that the RTC is correctly configured.\nThe first step is to Attach to the tag (through a base connected by USB). Once the tag is attached, its real time clock can be set (based upon the host clock). In this example, the host sleeps for 2 seconds and then reads the tag status which includes its current RTC value in milliseconds. Finally, the test program computes the clock drift. While this may appear a useless exercise, it can detect whether the tag RTC is misconfigured or not running.\n int main(int argc, char **argv) { using MS = chrono::milliseconds; Tag tag; Status status; int64_t millis; if (tag.Attach()) { // set the RTC  tag.SetRtc(); // sleep 2 seconds  this_thread::sleep_for(MS(2000)); // Read the RTC  tag.GetStatus(status); // Compute drift  auto now = chrono::system_clock::now(); auto ts = chrono::time_point_cast\u003cMS\u003e(now); float error = (status.millis() - ts.time_since_epoch().count())/1000.0; cout \u003c\u003c \"Clock Error: \" \u003c\u003c error \u003c\u003c endl; } }    Communication Model Recall our basic system model consisting of a tag and an associated base..\n  For communication between the base and a tag, we utilize a standard serial interface present in all ARM based processors – the SWD (serial wire debug) protocol for communication. By utilizing this interface, our architecture can, in principle, support tags built with any ARM Cortex embedded processor. The physical host/base communication utilizes the ST Microelectronics stlink protocol over USB. By leveraging these existing interfaces, we can exploit off-the-shelf tools to program and debug tags. For example, we use openocd, an open source package that supports the stlink protocol, for programming and debugging the tag firmware. The only host device driver required is libusb, which is supported on large number of operating systems including linux, windows, and OS X.\nOur system architecture leverages these physical and link-layer protocols (swd/stlink/usb) to support host-tag communication. Host-tag communication is implemented with a simple remote procedure call (RPC) protocol that commnicates through the SWD debugger interface with the tag processor and utilizes a feature of Cortex-M3 and Cortex-M4 based processors that supports “debug monitor” interrupts. The RPC messages are encoded with the Google Protocol Buffers message format.\nWe support the tag host library described previously with a low-level interface that communicates over USB to the base and through the base over SWD to the tags. The definition for this interface is:\nbool Attach(UsbDev dev = UsbDev()); void Detach(); bool Voltage(float \u0026voltage); bool Rpc(size_t *size); size_t MaxPacket(); There are methods for attaching/detaching that mirror those in the tag library, a few methods for status information (Voltage(), MaxPacket(), and a remote procedure call (Rpc) method that uses a private buffer for the exchange. As we shall see, our Protocol Buffer definitions include two major messages – Req and Ack supported by a number of other message types. Hosts send requests (Req) to tags and receive acknowlegements (Ack) in return.\nProtocol Definitions As discussed above, communication with the tags is implemented through a remote procedure call mechanism encoded with protocol buffers. The Req(uest) message is defined as illustrated to the right. A request message contains on of the various choices. For example, the current tag state is requested with a request containing an (empty) get_status message and the current configuration is requested with an (empty) get_config message. Some request messages are non-empty. For example, the start request is encoded as a Config message, which, as we shall see, carries all of the information necessary to configure a tag such as start/stop times, hibernation periods, sensor and data logging configuration.\nThe current system and data logs can be requested with log message. The LogReq message type will be discussed subsequently.\nIn the protocol buffer languages message fields have unique tags (here,the integers 1-9). These tags play an important role in encoding and decoding messages. Furthermore, (sub)-messages can be defined as new types and their contents embedded in other messages. An important characteristic of the encoding/decoding process for protocol messages is that unknown fields are ignored; the consequence of this is that messages in our application can be extended with new fields to support new types of tags without breaking backwards compatibility with exisitng tags.\n message Req { oneof payload { // Information  Empty get_info = 1; // static tag information  Empty get_status = 2; // current tag status  Empty get_config = 3; // current tag configuration  // control  Empty erase = 4; // erase tag (return to Idle)  Config start = 5; // configure \u0026 start tag  Empty stop = 6; // stop tag  TestReq test = 7; // start test  int64 set_rtc = 8; // set clock (milliseconds)  // logs -- see log message for types  LogReq log = 9; }}   Tag info is returned as a message with fields matching the C++ interface described above.  enum Info { Info_NOT_DEFINED = 0; MONITOR = 1message TagInfo { TagType tag_type = 1; // tag type (should match config)  // hardware  string board_desc = 2; // board description  string uuid = 3; // processor unique id  int64 intflashsz = 4; // internal flash size (bytes)  int64 extflashsz = 5; // external flash size (bytes)  // software  string firmware = 6; // firmware description  string gitrepo = 7; // git repo  string githash = 8; // git version hash  string source_path = 9; // path to source in repo  string build_time = 10; // build time }   Because of the properties of protocol buffers, the definitions for the Req message and Info enumerated type can be extended as needed for additional tag types. The only requirement is that the additional fields are given new and unique numbers. These additional fields will be ignored by tags not supporting them.\nEvery Req sent to a tag must be acknowledged. The Ack(nowlegemnt) message contains two fields – an error code and return data of various types. The data returned in response a Req depends both upon the type of the request and the type of the tag. This is particular the case for log data. This example provides a single log data type. New tags or tag firmware may necessitate adding additional return types.  message Ack { enum Err { UNSPECIFIED = 0; OK = 1; // Host Error  EMPTY_RETURN = 2; // return type unexpected  MONITOR = 3; // reserved for monitor  // Tag Error  NODATA = 4; // no data  INVAL = 5; // invalid operand  PERM = 6; // operation not permitted  NXIO = 7; // operation failed  NANOPB = 8; // nanopb error  } Err err = 1; oneof payload { TagInfo info = 2; Config config = 3; // configuration return  Status status = 4; // current status  string error_message = 5; // debugging support  // Log types  StateLog system_log = 6; BitTagLog bittag_data_log = 7; ... other data log types added as needed ... }}   The protocol definitions include a number of specialized messages for carrying data including tag status, configuration, and data/system log messages. For example, the tag status message includes the current state (from the tag lifecycle diagram), current RTC value, and various other internal information:\nenum TagState { STATE_UNSPECIFIED = 0; TEST = 1; // self test in progress  IDLE = 2; // ready  CONFIGURED = 3; // configured  RUNNING = 4; // actively collecting data  HIBERNATING = 5; // running, but not active  ABORTED = 6; // error, or stop received  FINISHED = 7; // normal termination  sRESET = 8; // reset in progress  EXCEPTION = 9; // unhandled exception }message Status { int64 millis = 1; // current time in ms  TagState state = 2; // current state  TestResult test_status = 3; // test result  int32 internal_data_count = 4; // number of internal data entries  int32 external_data_count = 5; // number of external data entries  float voltage = 6; // system voltage  float temperature = 7; // processor Temperature }With the creation of new tags, some message types are extended (configuration) and new message types added (data logs). In general, the protocols for our tags are designed to be extensible in the sense that these changes should be backwards compatible with existing tags.\nTag Firmware The tag firmware, written using the ChibiOS RTOS and using the Nanopb implementation of protocol buffers is organized as two threads. One that executes the state machine in the lifecycle and the other, which is only created when an external device connects, handles protocol buffer communications with the host.\nThe state machine organization allows us to isolate the changes necessary to create new tags. In particular, only the portions of the code related to configuration, data collection, and data logging need to change. Creating a tag with a new type of sensor requires providing a device driver for the sensor and routines to initialize and query the sensor. Furthermore, it requires extending the configuration message, mechanisms for storing and retrieving the configuration, and the mechanisms for storing and retrieving data.\n","categories":"","description":"","excerpt":"The system software for NanoTags consists of firmware (the software …","ref":"/docs/architecture/software/","tags":"","title":"Software Architecture"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/architecture/","tags":"","title":"Tag Architecture"},{"body":"To be usable, data logging tags require software applications to configure them prior to “flight” and to access any data collected “post-flight”. The NanoTag architecture is supported by an extensive software system that includes the base-boards used to charge the tags, a software library to support communication with the tags via a USB connection to the baseboard, and applications including a graphical user interface (GUI) tool – the NanoTag Monitor – and a collection of command-line tools for querying and testing tags. Collectively, these tools support the tags through the build process and through their use in biological expariments. In this section, we focus on the use of these tools rather than their underlying architecture.\nNanoTag Monitor The primary tool for use by biologists is the NanoTag monitor. This tool, provides the ability to gather metadata about a tag (for example, it’s hardware and firmware revisions), to read and write configurations used in experiments, to synchronize the on-board clock, and to access tag data post-experiment. The monitor screen, displayed to the right, includes a number of tabs – “Tag State”, “Configure”, and “Error Log” – to access various features. The “Tag State” tab includes information about the the tag hardware and software, the current tag status, and various controls.  Fig. 1 NanoTag Monitor    Tag State Tab The status area of the Tag State tab, provides the current state – in this case “IDLE”, the clock error, the current battery voltage, and the status of the tag self-tests (which should be run before deployment). The tag clock can be synchronized to the host computer (Sync button).  Fig. 2 NanoTag Monitor (Status)     Tag Information includes the following\n Tag Type : The type of tag being accessed. Board Name : The specific board hardware Firmware : Tag firmware (software) version Flash Size : Amount of storage on the tag UUID : The processor unique identifier which can be used to uniquely identify a specific tag Git Repo : The git repository. This can be used to retrieve the tag software and hardware sources Source Path: The location of the tag software in the repository GitHash : The hash used to identify the specific repository contents used to build the tag software Build Date: The date when the tag software was built.   Fig. 3 NanoTag Monitor (Information)     The Tag State tab provides two important sets of controls. A running tag can be stopped (button disabled in the IDLE state), a stopped tag can be erased (button disabled), and self-tests can be executed (on an idle tag). The NanoTag monitor can be Detached from the base (and subsequently Attached). It is advisable to Detach the base, or close the NanoTag monitor, prior to unplugging the base and removing a tag.  Fig. 4 NanoTag Monitor (Control)     The final control area of the Tag State tab is the Data area. A tag that has executed and stopped can have its data downloaded by the Data save button. BitTags have only an internal data log, but some tags may additionally have external data logs stored in an external flash. The count field gives an indication of the amount of data available for download.  Fig. 5 NanoTag Monitor (Data Save)     Configuration Tab The configuration tab provides several sub-tabs for configuring the data collection schedule (start/end times and hibernation periods), the data to be logged, and tabs for configuring sensors. The BitTag has a single sensor – the adxl362 accelerometer, but other tags may have different or additional sensors. The specific set of configuration sub-tabs is tag specific.\nThe schedule for an experiment is determined by the start and stop times and any periods when data collection should be suspended. It is important to remember that all times are UTC. By default, data collection begins immediately and runs until storage or energy are exhausted. Hibernation periods are defined by the start and end times – the BitTag supports two such periods) Schedule times are limited to hour level precision.\n Fig. 6 NanoTag Monitor Configuration     The configuration tab has two sets of controls (visible in all sub-tabs). The current configuration can be saved to or restored from a file. This is particularly useful for designing a common configuration for multiple tags to be used in a single experiment. A (future) command-line tool will use such a stored configuration to enable rapid configuration of a set of tags.\nThe current tag configuration can be read. Finally, the configuration can be written to the tag – and consequently data collection begun – with the start button.\nFig. 7 NanoTag Monitor Configuration Controls   Data Logging Configuration The allowable log configurations are tag specific. For the BitTag, the only configuration control is the aggregation period. Activity is measured on a per-second basis and may be stored as a bit-per second, counts/minute, counts/four minutes, and counts/five minute. The primary determining factor is the total amount of data that can be stored. The BitTag can store approximately 15,000 data records in its internal memory. A record consists of a time stamp, battery voltage, temperature, and some number of aggregation bits. At the highest resolution, the maximum collection period is 10 days while at the lowest resolution the tag can store a full year of data.\n   Resolution Maximum Collection Period     Bit/second 250 hours   Count/minute 2500 hours   Count/four minutes 332 days   Count/five minutes 364 days     Fig. 8 NanoTag Data Logging Configuration     Sensor Configuration The BitTag only has a single sensor – the Adxl362 accelerometer – and is used only as an activity detector. There are a number of parameters that can be configured including the accelerometer sample rate, range (in units of gravity), and the filter. In most instances, the default parameters are appropriate. In addition, the activity detector can be configured by setting the thresholds for transitions to active (active threshold), inactive (inactive threshold), and the time that a tag must stay below the inactive threshold to return to the inactive state (inactivity).  Fig. 9 NanoTag Sensor Configuration     Error Log The primary function of the Error Log tag is to provide debugging information. If errors occur in the monitor software, corresponding logging information is displayed in this tab. The contents of the error log can be saved to a file. In addition, the current tag and monitor configurations can be printed to the log.  Fig. 10 NanoTag Error Log     Configuration Files The tag configuration can be saved (and restored from) a human-readable (JSON) file. Notice that every section of the configuration gui has a corresponding section in the configuration files. Dates/times are recorded as Unix Epochs (seconds since 1/1/1970). These can be checked with an on-line tool such as Epoch Converter.  { \"tag_type\": \"BITTAG\", \"active_interval\": { \"start_epoch\": 1606230000, \"end_epoch\": 1606406400 }, \"hibernate\": [ { \"start_epoch\": 1606233600, \"end_epoch\": 1606237200 }, { \"start_epoch\": 1606244400, \"end_epoch\": 1606248000 } ], \"bittag_log\": \"BITTAG_BITSPERFIVEMIN\", \"acceltag_log\": \"ACCELTAG_UNSPECIFIED\", \"adxl362\": { \"range\": \"R4G\", \"freq\": \"S50\", \"filter\": \"AAquarter\", \"act_thresh_g\": 0.35, \"inact_thresh_g\": 0.35, \"inactive_sec\": 0.5 } }    ","categories":"","description":"qtmonitor -- the tag configuration and data download application\n","excerpt":"qtmonitor -- the tag configuration and data download application\n","ref":"/docs/userguides/qtmon/","tags":"","title":"Tag Configuration"},{"body":"","categories":"","description":"\"Talks about NanoLoggers.\"\n","excerpt":"\"Talks about NanoLoggers.\"\n","ref":"/talks/","tags":"","title":"Talks"},{"body":"Guide to Building Leg Loop Harness For Activity Loggers This material adapted from guide written by Dillon Gaugon\nThis guide demonstrates a method to build a leg loop harness for use on birds.\nThe following empirical formula, presented in 1, provides an effective guide for ornithologists seeking to build harnesses for data loggers and trackers.\n$\\texttt{harness span} = 14.16 + 8.34*\\texttt{body mass}^{0.437}$\nThe formula, based upon published data from a variety of species should provide a reasonable starting point for size.\n  Naef-Daenzer, Beat. An allometric function to fit leg-loop harnesses to terrestrial birds. Journal of Avian Biology, 38:404-407, 2007. ↩︎\n    Loop Harness: Naef-Daenzer 2007    For application of loggers with animals, an individual with the proper permits and training will need to be found or trained by someone with previous experience.\nStep 1: Materials  First, you’ll need to gather your materials Six Thumbtacks Elastic bead cord 1mm (can be obtained at any arts and crafts store) Small scissors or a razor blade (needs to be sharp to cut string) Nail Polish (to glue knots together) or super glue White paint marker or sharpie (to mark the string) Ruler A corkboard A NanoTag Activity Logger   Fig. 1 Loop Harness Materials    Step 2: Start Building !  Begin with a size in mind – you will not be able to measure until later in the process; however, on Juncos we commonly use 42-44mm. Put the string through a hole on the opposite side of the battery. Put string through and leave about double the length of your desired size. So, for 40mm loggers, leave about 80mm. Make sure that the string does not go over the side with the gold dots! These will face down onto the bird’s back.   Fig. 2 Start Building    Step 3: Safety Knot !  Tie a knot at the base of the second hole that you will put the string through. Make sure you still leave plenty of string! Make sure it is set up so that the knot will stay at the base. To make charging easiest, check that the knot is not on the side with the gold dots!   Fig. 3 Safety Knot     Step 4: Finish Threading Loops ! Put the string through the rest of the holes so that two loops can be made.  Fig. 4 Finish Threading Loops     Step 5: Measure Your Harness  You should have measurements in mind before you start building a harness However, you will only be able to get an accurate measurement of harness size at this step Take two thumbtacks and place them so that their distance is your desired size Place the logger around the two thumbtacks; here it measured below for about 43 mm It’s important to note that the logger is not holding itself together yet! The untied portion is being held taught to estimate the desired size.   Fig. 5 Measuring the Harness     Step 6: Mark Your String  Holding the harness tight, but not too tight, make a mark on the strings so that a knot may be tied on the base of the left side of the logger. Again, make sure not to have the string too tight (if the thumbtacks are being pulled off the board, it’s too tight.)   Fig. 6 Marking the Harness    Step 7: Tying Off  Use the white marks to line up the knot to the size you had measured (there will be some estimation involved but you can always refer to your tacks). The knots should be tied so that they will stay at the base of the logger (notice the tape, that will need to be applied over the gold dots after charging) Make sure to check your size, once you have tightened the knot and cut the extra strings.   Fig. 7 Tying the Harness    Step 8: Sealing the Knots  Apply nail polish to the knots as shown so that the knots will hold. It will dry and function as glue (it is also optional to use super glue) Try not to use so much that it gets on the rest of the logger.   Fig. 8 Sealing the Knots    Step 9: Admire Your Work  Congratulations! You have finished ! You can refer to your tacks one last time to make sure that your measurements have been accurate.   Fig. 9 Admire Your Work    ","categories":"","description":"Loop Leg Harness Construction","excerpt":"Loop Leg Harness Construction","ref":"/docs/userguides/legharness/","tags":"","title":"Loop Harnesses"},{"body":"The BitTag visualization application (btviz) allows exploration of data files created using the BitTag monitor. The tool provides mechanisms to graphically explore data by “zooming” in on regions of interest, to visualize the data via actograms, and to generate graphics (png) files from the user defined graphs. In addition, the data exploration tool supports data aggregation and smoothing.\n1. Loading When the tool is opened, the initial screen provides a single action – load (Fig. 1)\nFig. 1: btviz Start Screen  The load action will open a dialog that filter ‘.txt’ files – the files created by the tag monitor tool are all human readable text files. When a file is opened, the activity data for the full time range are displayed. (Fig. 2)\n Fig 2: Raw Data  Notice that in this example, there are three distinct regions – the first and last have minimal activity and the middle has a great deal of activity. The first and last regions correspond to pre and post experiment – the tag was active, but not on a bird ! It’s easy to demonstrate this by displaying the tag temperature data (Fig. 2).\nThe data are displayed as “percentages”. To understand what this means, consider that the BitTags collect activity data as counts of active seconds in a given collection period (for example, 5 minutes). The activity percentage in a collection period is computed by dividing the count by the length of the collection period (in seconds).\n Fig 3: Temperature  Notice that in the middle period, the temperature is around 38C – corresponding (roughly) to a Junco’s body temperature. With captive animals, a common issue is the loss of a tag due to harness failure. If the tag is recovered, the temperature data is important for selecting the valid data periods. The visualization tool also can display the tag battery voltage – this is important for understanding battery lifetimes.\n2. Zooming and Scrolling At the default scale with a long collection period, it is difficult to see any patterns. The tool supports “zooming” and scrolling in the data. Using the mouse buttons/track pad/scroll wheel – some experimentation my be required to determine how to do this on the various platforms on which the tool runs ! For example, the Fig. 4 shows the data for roughly one week.\n Fig. 4: Zoom and Scroll  To return to the full data screen, use the “reset” button (Fig. 5)\n Fig. 5: Reset to Full View  It is also possible to zoom to a pair of cursors (set with the left, right mouse buttons – os x ctl + click ) or by setting the desired dates. (Fig. 6)\n Fig. 6: Using Cursors  3. Data Smoothing Sometimes it is difficult to discern interesting aspects of the data because there appears to be too much noise. In this case it may be helpful to smooth the data. There are two types of smoothing filters implemented by the tool – moving average and exponential moving average (Fig. 7).\n Fig. 7: Data Smoothing  4. Export Figures and Selected Data The current graph can be exported in several ways (Fig. 8):\n printed saved as a PDF file saved as a PNG file data exported to CSV   Fig. 8 Data/Graph Export  5. Actograms In addition to exploring the raw data, the tool provides a means to explore via actograms (Fig. 9)\n Fig. 9 Actograms  The actograms can be configured in the following ways\n start day : first day displayed days : number of days displayed single/double (24 or 48 hours) range as a maximum activity percent (PercentLimit) time zone (offset from UTC) title for actogram.  In addition, the actogram can display actual (for a given location) or simulated sun elevation. (Fig. 10).\n Fig. 10 Sun Elevation  Simulated elevation can be used for captive animals to indicate the periods of light. Currently, the model is quite basic consisting of a csv (comma separated data) file containing the start/stop data/times for periods of light. All times are UTC.\n04/01/2019 11:00:00,04/01/2019 23:59:59 04/02/2019 11:00:00,04/02/2019 23:59:59 04/03/2019 11:00:00,04/03/2019 23:59:59 04/04/2019 11:00:00,04/04/2019 23:59:59 04/05/2019 11:00:00,04/05/2019 23:59:59 Finally the actogram can be exported as a PDF or PNG file.\nTag Metadata The data files include information about the experiment configuration including collection periods, activity detection, hardware and software versions, and the final clock error (Tag error). This information can be important for documenting the experiment. It can also be read directly from the data file. (Fig. 11)\n Fig. 11 Tag Metadata  ","categories":"","description":"btviz -- the BitTag data visualization tool\n","excerpt":"btviz -- the BitTag data visualization tool\n","ref":"/docs/userguides/btviz/","tags":"","title":"Visualization"},{"body":"The software library upon which the configuration tool is built makes it easy to create command-line tools. For example, we make extensive use of a tag-test tool during the tag build process. This tool sets and checks the internal clock and runs the tag self-test routines.\n~/Research/NanoTag/build$ ./bin/tag-test Board name: BitTag V5 Build time and date: Nov 22 2020 : 10:29:27 Internal Flash size: 256kb External Flash size: 0kb Repo: git@github.iu.edu:geobrown/NanoTag.git Repo hash: 3bde753 UUID: 20383055324850090051006E Voltage: 3.04 Initial Clock drift: -0.07 # Checking RTC (2 second delay) Clock drift after setting: -0.02 State: IDLE # Running test Test Result: ALL_PASSED We have planned, but not yet built, a tool to configure tags from stored configuration files. This tool will:\n run the self-test synchronize the clock print tag information configure the tag from a file  We have developed a simple command line tool – tag-dwnld that downloads data from stopped tags. In addition, we have developed a primitive command line interfaces tag-cli that admits reading the status from, stopping, and erasing tags.\n","categories":"","description":"Tag configuration, testing, and data downloading using command line tools\n","excerpt":"Tag configuration, testing, and data downloading using command line …","ref":"/docs/userguides/cli/","tags":"","title":"Command-Line Tools"},{"body":"Energy and Power The dominant issue in developing long-life sub-gram tags is energy. In the tags we describe, all of the required energy must be carried in the form of batteries – we do not consider energy harvesting because of the additional complexity of power management circuitry, weight for harvesting devices (e.g. solar cells), and, for solar, the likelihood that a solar cell will frequently be obscured. Power delivery is a closely related issue; as we will show, many of the small batteries that are suitable for our tags can deliver limited peak power which necessitates additional load capacitors to deliver high peak power for sensing and writing flash. However, capacitors bring their own set of issues in the form of leakage currents and board area. In the following section we consider the energy and power requirements of small tags, techniques for minimizing energy requirements, our approach to measuring energy and power requirements for real tags, and techniques for estimating the energy requirements for a planned experiment. Although much of our discussion is generalizable, we necessarily focus upon the specific components used in our tags.\nEnergy Sources The primary energy source in our tags are batteries; however, in order to meet the peak power requirements for writing flash memory and for some types of sensors (e.g. magnetometers), it is necessary to supplement batteries with capacitors.\nBatteries While there are many possible battery chemistries, we have restricted our attention to rechargeable cells with voltages greater than 2 volts. The most obvious choices are Lithium Polymer (Li-Po) and Lithium Manganese (Li-Mn). The smallest available Li-Po cells weigh approximately 0.4g and have relatively high peak power delivery (e.g. 10mA), but they have several significant limitations – it is difficult to obtain small quantities of well characterized sub-gram Li-Po batteries, the cells are physically fragile, and their peak voltage (4.2\\si{\\volt}) necessitates additional circuitry for power management.\nIn contrast, physically robust, well characterized Li-Mn batteries with 3.2V peak voltage are available in a variety of sizes. Their primary limitation is the high internal impedance ($\\Omega$) which severely restricts peak power. By utilizing Li-Mn batteries, our tags can be configured at different weights depending upon the animal species being studied and the length of the planned experiments. For example, our partners studying pine siskins and great tits require tags below 0.5g with 3 month lifetimes, which we achieve utilizing MS518 batteries, while year long studies with robins have been supported by 0.84g tags utilizing MS920 batteries.\nEstimating Energy and Power Accurate energy and power estimation for our tags requires active measurement of the various operating modes. The datasheets for the various devices provide architectural guidance, but are not sufficiently accurate for predicting tag lifetime or for determining peak power requirements. Furthermore, achieving the lowest energy utilization requires significant firmware tuning. For example, we minimize the cost of waking up from processor Standby by optimizing the firmware initialization code. Power measurement is an ongoing part of our software development process – we frequently iterate on firmware design based upon power measurements. In addition, relatively small configuration errors (for example in processor pin initialization or sensor initialization) can lead to significant “current leaks”.\nThe dynamic range of power requirements in our tags is roughly 5 orders of magnitude – 200nA-10mA – and involves peak power events as brief as 50us. In order to accurately measure power requirements we need a current monitor with high sample rate. We designed our tag bases to accept connection to the X-Nucleo-LPM01A – a programmable voltage source which can make dynamic power measurements from 100nA to 50mA at 100kHz sample rates with a claimed 2% accuracy.\nTo the right is a screen capture from the X-Nucleo software illustrating the idle power requirements of a BitTag with rv-3028 RTC. At this low current level, the software displays considerable noise. Nonetheless, the average current (238nA) is accurate – we have separately validated the low-current performance with a Keithley 6485 picoameter.    The STM32L432 datasheet predicts that a 64 bit flash write takes 80-90 us and requires 3.4mA (average current). The adjacent figure illustrates a complete log-write sequence (two 64 bit writes) from processor wake up to return to standby. Although the current during the write pulses (to the extreme right) appears somewhat lower than predicted, the overall behavior is consistent with the datasheet estimate. Notice also the small current spike that occurs at the transition from Standby to running. The datasheet predicts a 1.23mA spike for 20us during this transition – this is at the limit for the 100kHz sample rate of our measurement board.    In estimating peak power requirements, we utilize a feature of the LPM01A software that integrates current (and energy) over time; for example, the average current in the illustrated example was 424uA and the total energy was 2.74uJ at 2.5V and the pair of flash writes required 1uJ energy or 0.4uC charge. We can compute the load capacitance required to support these writes for a given voltage drop limit using the equation: $$ Capacitance\\ = \\ \\frac{q}{V} $$\nFor a maximum 0.1V drop, the required load capacitor is then $$\\frac{0.4\\mu C}{0.1V}\\ = \\ 4\\mu F $$ In practice, the capacitor size would need to be adjusted to compensate for physical effects such degradation with temperature and DC load.\nDevelopment Platform In order to facilitate the rapid prototyping of new tag designs and the evaluation of candidate sensors, we created a development platform that combines the interfaces of our base board with the processor and RTC required for our tags. In the following figure, this platform is illustrated along with a basic “daughter” card and includes an AT25XE321 flash memory and and adapter to support the large variety of sensor evaluation boards from ST Microelectronics. In addition, one commercial (top right) and one custom (bottom right) sensor evaluation board are illustrated supporting LPS27 pressure sensor, and OPT3002 light sensor that we use in this section. Most commercial sensors are supported by manufacturer or third party evaluation boards (so-called breakout boards). While the platform base required commercial fabrication, the daughter card and OPT3002 breakout boards were fabricated in house with basic soldering equipment.\nCustom Tags To demonstrate the use of our system architecture for the development of custom tags, we developed three custom ``tags'' with an accelerometer (LIS2DW12), a pressure sensor (LPS27), and a light sensor (OPT3002). These are three of the most commonly used sensor types for avian behavior studies.\nWhile the BitTag has an accelerometer that has exceptional low-power activity detection, the LIS2DW12 has sophisticated digital low and high-pass filters that may be more suitable logging other behaviors such as body position or flight; such behavior detection has been used in several notable experiments.\n(Citation: Liechti, Witvliet \u0026 al., 2013Liechti,  F.,  Witvliet,  W.,  Weber,  R. \u0026 Bächler,  E.   (2013).  First evidence of a 200-day non-stop flight in a bird. Nature Communications, 4(1). 2554–2554. https://doi.org/10.1038/ncomms3554 ) , (Citation: Liechti, Bauer \u0026 al., 2018Liechti,  F.,  Bauer,  S.,  Dhanjal-Adams,  K.,  Emmenegger,  T.,  Zehtindjiev,  P. \u0026 Hahn,  S.   (2018).  Miniaturized multi-sensor loggers provide new insight into year-round flight behaviour of small trans-Sahara avian migrants. Movement Ecology, 6(1). 19–19. https://doi.org/10.1186/s40462-018-0137-1 ) , (Citation: Hedenström, Norevik \u0026 al., 2016Hedenström,  A.,  Norevik,  G.,  Warfvinge,  K.,  Andersson,  A.,  Bäckman,  J. \u0026 Åkesson,  S.   (2016).  Annual 10-Month Aerial Life Phase in the Common Swift Apus apus. Current Biology, 26(22). 3066–3070. https://doi.org/10.1016/j.cub.2016.09.014 ) A commonly used measurement to detect flight modes and estimate energy expenditure is the ``vectorial dynamic acceleration'' (VeDBA). (Citation: Stothart, Elliott \u0026 al., 2016Stothart,  M.,  Elliott,  K.,  Wood,  T.,  Hatch,  S. \u0026 Speakman,  J.   (2016).  Counting calories in cormorants: dynamic body acceleration predicts daily energy expenditure measured in pelagic cormorants. Journal of Experimental Biology. jeb.130526. https://doi.org/10.1242/jeb.130526 ) , (Citation: Williams, Shepard \u0026 al., 2015Williams,  H.,  Shepard,  E.,  Duriez,  O. \u0026 Lambertucci,  S.   (2015).  Can accelerometry be used to distinguish between flight types in soaring birds?. Animal Biotelemetry, 3(1). 45–45. https://doi.org/10.1186/s40317-015-0077-0 ) , (Citation: Spivey \u0026 Bishop, 2013Spivey,  R. \u0026 Bishop,  C.   (2013).  Interpretation of body-mounted accelerometry in flying animals and estimation of biomechanical power. Journal of The Royal Society Interface, 10(87). 20130404. https://doi.org/10.1098/rsif.2013.0404 ) , (Citation: Gleiss, Wilson \u0026 al., 2011Gleiss,  A.,  Wilson,  R. \u0026 Shepard,  E.   (2011).  Making overall dynamic body acceleration work: on the theory of acceleration as a proxy for energy expenditure. Methods in Ecology and Evolution, 2(1). 23–33. https://doi.org/https://doi.org/10.1111/j.2041-210X.2010.00057.x ) VeDBA is the magnitude of the high-pass filtered acceleration vector. The low-pass filtered acceleration vector can be used to accurately compute the pitch and roll angles for an accelerometer tag.\nPressure sensors have been shown to have great utility in understanding the behavior of birds during migration. For example, (Citation: Dhanjal-Adams, Bauer \u0026 al., 2018Dhanjal-Adams,  K.,  Bauer,  S.,  Emmenegger,  T.,  Hahn,  S.,  Lisovski,  S. \u0026 Liechti,  F.   (2018).  Spatiotemporal Group Dynamics in a Long-Distance Migratory Bird. Current Biology, 28(17). 2824–2830.e3. https://doi.org/10.1016/j.cub.2018.06.054 ) demonstrated that by comparing pressure measurements over time it is feasible to determine which animals from a given site migrate together, (Citation: Liechti, Bauer \u0026 al., 2018Liechti,  F.,  Bauer,  S.,  Dhanjal-Adams,  K.,  Emmenegger,  T.,  Zehtindjiev,  P. \u0026 Hahn,  S.   (2018).  Miniaturized multi-sensor loggers provide new insight into year-round flight behaviour of small trans-Sahara avian migrants. Movement Ecology, 6(1). 19–19. https://doi.org/10.1186/s40462-018-0137-1 ) demonstrated that one can reliably use pressure measurements to determine when animals are migrating, and (Citation: Sjöberg, Malmiga \u0026 al., 2021Sjöberg,  S.,  Malmiga,  G.,  Nord,  A.,  Andersson,  A.,  Bäckman,  J.,  Tarka,  M.,  Willemoes,  M.,  Thorup,  K.,  Hansson,  B.,  Alerstam,  T. \u0026 Hasselquist,  D.   (2021).  Extreme altitudes during diurnal flights in a nocturnal songbird migrant. Science, 372(6542). 646–648. https://doi.org/10.1126/science.abe7291 ) determined that small animals may fly above 5000 meters during migration. A sub-gram pressure tag has previously been developed, but with significantly less storage and greater energy requirements than the one presented in this paper. \\cite{shipley2018mee}\nFinally, light-level geolocation is one of the fundamental techniques used to determine the paths taken during migration. (Citation: Hill \u0026 Braun, 2001Hill,  R. \u0026 Braun,  M.   (2001).  Geolocation by Light Level. InElectronic Tagging and Tracking in Marine Fisheries. Reviews: Methods and Technologies in Fish Biology and Fisheries, vol 1... https://doi.org/10.1007/978-94-017-1402-0_17 ) , (Citation: Fudickar, Wikelski \u0026 al., 2012Fudickar,  A.,  Wikelski,  M. \u0026 Partecke,  J.   (2012).  Tracking migratory songbirds: Accuracy of light-level loggers (geolocators) in forest habitats. Methods in Ecology and Evolution, 3(1). 47–52. https://doi.org/10.1111/j.2041-210X.2011.00136.x ) While commercial light-level geolocation tags are available, geolocation in combination with acceleration or altitude data seems especially useful.\nIn practice, it may be desirable for specific experiments to combine various combinations of these sensors. For example, light, pressure, and temperature can be combined with weather data to determine altitude. Pressure, temperature, an altitude have been used to study the flight behavior of soaring birds. (Citation: Williams, Shepard \u0026 al., 2020Williams,  H.,  Shepard,  E.,  Holton,  M.,  Alarcón,  P.,  Wilson,  R. \u0026 Lambertucci,  S.   (2020).  Physical limits of flight performance in the heaviest soaring bird. Proceedings of the National Academy of Sciences, 117(30). 17884–17890. https://doi.org/10.1073/pnas.1907360117 ) . In addition, the data collection protocol might vary considerably for different types of experiments. In some cases, high frequency data for days or weeks is required while in migration studies lower frequency data over months is required.\nResults We “built” three prototype tags using the breakout board illustrated in Fig.~\\ref{fig:tagbreakout}, commercial sensor evaluation boards for the accelerometer (STEVAL-MKI179V1) and pressure sensor (STEVAL-MKI213V1) tags; and a custom sensor board for the light sensor board. The accelerometer was configured to be ``always on'' and the other sensors had their power supplied through a processor pin. We modified the pressure sensor board by removing a $10 \\mu F$ capacitor.\nThe data collection protocol for all three tags was synchronous – based upon a configured period (e.g. 60 seconds), a running tag wakes, measures the required data, and stores one or more values. The light sensor tag collects a single value – the received optical power in $\\frac{nW}{cm^2}$. The pressure sensor tag collects two values – the pressure in hPA and the temperature in $\\circ C$. The LPS27 pressure sensor was configured in ``low-current mode'' (5.6Pa RMS noise). Similarly, the OPT3002 was configured for the shorter 100ms conversion time with somewhat reduced resolution.\nThe data collection protocol for the acceleration tag is more complex. The tag stores two values for each collection period – pitch angle of the tag and VeDBA (vector dynamic acceleration) averaged over a sampling window. The tag was configured to collect 14-bit data in ``low-power mode 1'' (4.5mg RMS noise) and to utilize both low and high-pass filters to measure static and dynamic acceleration, respectively. In both cases the filters are configured with cutoff frequencies $\\frac{1}{20}$ of the 25Hz sample rate. For static acceleration, data were collected and discarded for 12 sample periods to satisfy the filter delay. The resulting static acceleration vector ($g_x,g_y,g_z$) was used to compute the pitch angle $\\theta$ using the formula $$ \\theta\\ = \\ \\frac{-g_x}{\\sqrt{g_y^2+g_z^2}} $$ For dynamic acceleration, VeDBA was computed and averaged over 1 second. In practice, both sample rates and sampling duration should be chosen to match the wing-beat frequency and flap-glide patterns for the species under study. (Citation: Bruderer, Peter \u0026 al., 2010Bruderer,  B.,  Peter,  D.,  Boldt,  A. \u0026 Liechti,  F.   (2010).  Wing-beat characteristics of birds recorded with tracking radar and cine camera. Ibis, 152(2). 272–291. https://doi.org/https://doi.org/10.1111/j.1474-919X.2010.01014.x ) As described previously, the daughter card we developed has a 4MByte flash memory. In all three tags, data were stored as two-byte values. Thus, the prototype tags have sufficient storage for 2M samples – in practice energy will likely be the limiting factor. For example, the pressure and accelerometer tags have storage for a year with a 30 second sample period.\nThe following table provides the energy measurements obtained with our development platform and the data collection protocols described above. The table includes the idle current, cost of a single data sample, and expected lifetime with three possible batteries (MS518, MS614, and MS920). The expected mass with these batteries, based upon footprints that are identical to the BitTag are (0.5g, 0.6g, and 0.85g, respectively).\n   Sensor Idle (nA) Sample (uJ) MS518 MS614 MS920     Accelerometer 300nA 57uJ 208 days 337 days 674 days   Pressure 230nA 30uJ 329 days 532 days 1065 days   Light 260nA 21.4uJ 351 days 569 days 1138 days    Required Software Changes It is somewhat challenging to quantify the software changes required to create new tags. The most time-consuming part is developing the code (driver) that controls the new sensors or other hardware devices. Although, for each of the sensors this ``driver'' code was less than 200 lines of C, writing the code required carefully reading and interpreting the sensor datasheet. In addition, all of the three tags utilize an external flash chip that was not part of the BitTag. While the code to support this flash chip, which we developed for an earlier project, is only about 300 lines, the effort required was substantial. Since all of the drivers developed in this project are reusable for other tags, in the following we focus on the other differences between our three example tags and the code necessary to integrate them into our host software.\nEach of the three codes differs slightly in three areas – configuration, logging, and data transfer. The specific code for logging data differs between the tags by fewer than 50 lines of code and the code for handling the new log messages differs by fewer than 50 lines between the various tags. For these examples, we made a single change to the configuration system – adding a sample period parameter that was not needed in BitTag, which samples based upon asynchronous activity.\nOn the host software side, each of the tags required a new routine for converting logging messages to text – approximately 100 lines of code for each including integration into the GUI tool and code libraries. Extending the protocol definitions to support the new logging and configuration messages required approximately 50 lines of code.\nFinally, for each tag we needed to integrate the code into the software build system. Although this requires only a few small changes, it does require knowledge of our build environment.\nOther Considerations Capacitor Leakage An important potential loss is due to the leakage current of the capacitors that are necessary to smooth power delivery in our circuits. A primary source of these losses is due to the insulation resistance of the capacitors themselves – which is specified by suppliers. Typically, this is specified in $\\Omega F $ for example, Murata specifies $ 50\\ \\Omega F $ for many its parts. We can calculate the expected leakage of a $ 1\\mu F $ capacitor at 2.5V as follows:\n IR : $ = 50\\ \\Omega F/1\\mu F \\ = 50\\times 10^{-6} \\Omega $ Leakage = $ 2.5V/50\\times 10^{-6} \\Omega = 50 nA $  Using the same formula, here are some the leakage currents at 2.5V for various capacitor sizes:\n   Capacitor Leakage (nA)     $ 0.1\\mu F $ 5 nA   $ 1\\mu F $ 50 nA   $ 4.7\\mu F $ 235 nA   $ 10\\mu F $ 500 nA    Given that our entire steady-state budget is under (hopefully way under) $ 1\\mu A $, it’s clear that we need to be thoughtful about our use of larger value capacitors. There is some good news – the insulation resistance formula is very conservative (perhaps as much a 10x) as described in this study.\nMost of the capacitors in our tag designs are quite small; however, we do require at least one larger capacitor to support writing the on-chip flash. For the stm32l4 processors, writing 64-bits takes $ 90\\mu s $ at $ 3.4 mA $ or $ 2.5 V \\times 3.4 \\times 10^{-3} A \\times 9.0 \\times 10^{-5} s == 0.765 \\mu J $ at 2.5 Volts. The energy stored in a capacitor is $ \\frac{1}{2}CV^2 $\nSuppose that we want to limit voltage sag to 0.1V then, we can compute the size capactor required as\n$ \\frac{1}{2}C (2.5^2 - 2.4^2) = 0.765 \\times 10^{-6} $\n$ C = \\frac{2 \\times 0.765 \\times 10^{-6}}{0.49} = 3 \\mu F $\nAt 2V (the minimum viable battery voltage), a $ 3.7 \\mu F $ capacitor is needed. Thus, a $ 4.7 \\mu F $ capacitor provides sufficient storage to handle 64-bit writes with less than 0.1V voltage drop.\nFabrication Constraints In order to facilitate the production of inexpensive prototypes and small fabrication runs, it is essential to use design constraints that are readily satisfied by low-cost providers. These constraints limit the design of the PCB (pc-boards) and the choice of component packages. For example, the smallest processor packages available are in so-called Wafer chip scale packages (WCSP) where the package size is essentially the semiconductor die size; however, the spacing of the pins for these packages is typically too close for low-cost low-volume production. Similarly, the smallest passive devices (capacitors and resistors) are available in 0201 packages (0.6mm x 0.3mm), while most of the fab houses we work with are recommend 0402 (1mm x 0.5mm).\nIn developing prototypes we have primarily used two suppliers – Macrofab and PCB:ng. For production runs we have used Macrofab and Circuit Hub. Here are a subset of their design rules (0.001in == 1mil).\n   Supplier Minimum Trace Width Minimum Via Diameter Smallest Package     Circuit Hub 6 mil 12 mil (24 recommended) 0402 (recommended)   MacroFab 5 mil 18 mil 0201   PCB:ng 4 mil 18 mil 0201   Our designs 5 mil 23 mil 0402    References   Bruderer,  Peter,  Boldt \u0026 Liechti (2010)  Bruderer,  B.,  Peter,  D.,  Boldt,  A. \u0026 Liechti,  F.   (2010).  Wing-beat characteristics of birds recorded with tracking radar and cine camera. Ibis, 152(2). 272–291. https://doi.org/https://doi.org/10.1111/j.1474-919X.2010.01014.x    Dhanjal-Adams,  Bauer,  Emmenegger,  Hahn,  Lisovski \u0026 Liechti (2018)  Dhanjal-Adams,  K.,  Bauer,  S.,  Emmenegger,  T.,  Hahn,  S.,  Lisovski,  S. \u0026 Liechti,  F.   (2018).  Spatiotemporal Group Dynamics in a Long-Distance Migratory Bird. Current Biology, 28(17). 2824–2830.e3. https://doi.org/10.1016/j.cub.2018.06.054    Fudickar,  Wikelski \u0026 Partecke (2012)  Fudickar,  A.,  Wikelski,  M. \u0026 Partecke,  J.   (2012).  Tracking migratory songbirds: Accuracy of light-level loggers (geolocators) in forest habitats. Methods in Ecology and Evolution, 3(1). 47–52. https://doi.org/10.1111/j.2041-210X.2011.00136.x    Gleiss,  Wilson \u0026 Shepard (2011)  Gleiss,  A.,  Wilson,  R. \u0026 Shepard,  E.   (2011).  Making overall dynamic body acceleration work: on the theory of acceleration as a proxy for energy expenditure. Methods in Ecology and Evolution, 2(1). 23–33. https://doi.org/https://doi.org/10.1111/j.2041-210X.2010.00057.x    Hedenström,  Norevik,  Warfvinge,  Andersson,  Bäckman \u0026 Åkesson (2016)  Hedenström,  A.,  Norevik,  G.,  Warfvinge,  K.,  Andersson,  A.,  Bäckman,  J. \u0026 Åkesson,  S.   (2016).  Annual 10-Month Aerial Life Phase in the Common Swift Apus apus. Current Biology, 26(22). 3066–3070. https://doi.org/10.1016/j.cub.2016.09.014    Hill \u0026 Braun (2001)  Hill,  R. \u0026 Braun,  M.   (2001).  Geolocation by Light Level. InElectronic Tagging and Tracking in Marine Fisheries. Reviews: Methods and Technologies in Fish Biology and Fisheries, vol 1... https://doi.org/10.1007/978-94-017-1402-0_17    Liechti,  Witvliet,  Weber \u0026 Bächler (2013)  Liechti,  F.,  Witvliet,  W.,  Weber,  R. \u0026 Bächler,  E.   (2013).  First evidence of a 200-day non-stop flight in a bird. Nature Communications, 4(1). 2554–2554. https://doi.org/10.1038/ncomms3554    Liechti,  Bauer,  Dhanjal-Adams,  Emmenegger,  Zehtindjiev \u0026 Hahn (2018)  Liechti,  F.,  Bauer,  S.,  Dhanjal-Adams,  K.,  Emmenegger,  T.,  Zehtindjiev,  P. \u0026 Hahn,  S.   (2018).  Miniaturized multi-sensor loggers provide new insight into year-round flight behaviour of small trans-Sahara avian migrants. Movement Ecology, 6(1). 19–19. https://doi.org/10.1186/s40462-018-0137-1    Sjöberg,  Malmiga,  Nord,  Andersson,  Bäckman,  Tarka,  Willemoes,  Thorup,  Hansson,  Alerstam \u0026 Hasselquist (2021)  Sjöberg,  S.,  Malmiga,  G.,  Nord,  A.,  Andersson,  A.,  Bäckman,  J.,  Tarka,  M.,  Willemoes,  M.,  Thorup,  K.,  Hansson,  B.,  Alerstam,  T. \u0026 Hasselquist,  D.   (2021).  Extreme altitudes during diurnal flights in a nocturnal songbird migrant. Science, 372(6542). 646–648. https://doi.org/10.1126/science.abe7291    Spivey \u0026 Bishop (2013)  Spivey,  R. \u0026 Bishop,  C.   (2013).  Interpretation of body-mounted accelerometry in flying animals and estimation of biomechanical power. Journal of The Royal Society Interface, 10(87). 20130404. https://doi.org/10.1098/rsif.2013.0404    Stothart,  Elliott,  Wood,  Hatch \u0026 Speakman (2016)  Stothart,  M.,  Elliott,  K.,  Wood,  T.,  Hatch,  S. \u0026 Speakman,  J.   (2016).  Counting calories in cormorants: dynamic body acceleration predicts daily energy expenditure measured in pelagic cormorants. Journal of Experimental Biology. jeb.130526. https://doi.org/10.1242/jeb.130526    Williams,  Shepard,  Duriez \u0026 Lambertucci (2015)  Williams,  H.,  Shepard,  E.,  Duriez,  O. \u0026 Lambertucci,  S.   (2015).  Can accelerometry be used to distinguish between flight types in soaring birds?. Animal Biotelemetry, 3(1). 45–45. https://doi.org/10.1186/s40317-015-0077-0    Williams,  Shepard,  Holton,  Alarcón,  Wilson \u0026 Lambertucci (2020)  Williams,  H.,  Shepard,  E.,  Holton,  M.,  Alarcón,  P.,  Wilson,  R. \u0026 Lambertucci,  S.   (2020).  Physical limits of flight performance in the heaviest soaring bird. Proceedings of the National Academy of Sciences, 117(30). 17884–17890. https://doi.org/10.1073/pnas.1907360117     ","categories":"","description":"Designing and programming custom tags\n","excerpt":"Designing and programming custom tags\n","ref":"/docs/custom/","tags":"","title":"Custom Tags"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/userguides/fabrication/","tags":"","title":"Fabrication"},{"body":"The NanoLogger system consists of software, both host and embedded, and hardware including printed circuit boards (PCBs) and 3D printed adapters. Consequently, there are a relatively large number of software tools involved. All of the software and hardware designs (source code) are available in the github repository. While you can explore that repository on-line, in order to compile the code and generate the processing files necessary to build boards, it is necessary to first clone the repository as described in Installing the Repository\nAn abbreviated view of this repository is shown in the following figure. There are two directories containing the designs for this project – software and hardware. Two directories that reference code from other projects as submodules – nanopb, which provides the compiler and libraries for the communication protocols used to exchange data and control messages with the tags, and ChibiOS, which is the embedded operating system (RTOS) used in the tags. Finally there is a directory (cmake) and files (CMakeLists.txt) used by the CMake build system.\n. ├── ChibiOS ├── cmake ├── CMakeLists.txt ├── hardware │ ├── AccelTag │ ├── BitTagv5 │ ├── BitTagv7 │ ├── CMakeLists.txt │ ... │ ├── Mechanical │ ... ├── nanopb ├── README.md └── software ├── CMakeLists.txt ├── embedded ├── host ├── include └── proto The hardware directory contains a separate directory for each board, libraries used by the Kicad, the computer aided design system (CAD) that we use to design hardware, and a directory of mechanical components (Mechanical) that includes the design files for the 3D printed bases.\nThe software directory includes separate sub-directories for embedded and host code, and a directory for the protocol definitions used to communicate between the host and the tags.\nAll of the software and hardware for NanoLoggers can be compiled (built) on Windows, OS X, or Linux. Enabling this process requires installing a number of programs and libraries. There are differences in the installation and build process for the three platforms that will be called out. In this section we describe the processes for cloning the NanoLogger repository and installing the CMake build system. The tools and libraries required to perform a build are discussed in separate sections for hardware and software.\n1. Installing the Repository In order to install the repository, you should use the program git, which is available on Windows, OS X, and Linux. Instructions for installing git can be found here\nOnce git is installed, copy the git repo link (for https) and execute the following in a terminal within the directory where you would like the repo installed\ngit clone https://github.iu.edu/geobrown/NanoTag-paper.git target_directory_name cd target_directory_name git submodule update --init --recursive The repository for this project includes two submodules – nanopb and ChibiOS; these are external repositories upon which our system builds. Nanopb is a code library and tool for creating the communication code used in our tags to communicate with the host applications. ChibiOS is an excellent embedded operating systems that is used on our tags.\nThe line git submodule... initializes these submodules and clones their contents.\n2. Installing the CMake Build Tool In order to automate the process of building the various system components, we use the CMake tool. This tool checks for the presence of all other necessary tools and issues warnings for any tools that are missing.\nCmake on OS X\nAdditional Installation For Windows make – gnu make is needed for building embedded software. The easiest way to install gnu make is with the chocolaty package manager. choco\nSetting up paths https://david.gardiner.net.au/2020/04/powershell-visualstudio-integration.html https://docs.microsoft.com/en-us/visualstudio/ide/reference/command-prompt-powershell?view=vs-2019#windows-10\nBuilding with CMake (additional softare required) Assuming all the necessary tools are installed the build process consists of creating a build directory, running CMake from within that directory, and then making any desired components. On a linux system, for example, the following sequence of commands will build the BitTag data visualization tool btviz.\nmkdir build_directory cd build_directory cmake path_to_repository make btviz The first two lines create a directory in which to build the system components; the third line populates this directory with the scripts necessary to perform the build (in this case Unix “make” files); finally, the fourth line builds the “target” btviz.\nContinuing the example, one can build and download the firmware to a BitTag (e.g. v6) that is connected to a base:\nmake BitTagv6-download The CMake build tool can be installed from here.\nThe various software targets that can be built include\n Host Tools  qtmonitor – the tag configuration tool btviz – the BitTag visualization tool various command-line tools   Tags  AccelTag – Tag design with ST Accelerometer BitTagv5 – BitTag with rv-8803 temperature compensated RTC BitTagv7 – BitTag with rv-3028 45nA RTC LuxTag – Tag design with light sensor NucleoTag – Tag “design” using STM Nucleo board for demonstration PresTAg – Tag design with LPS27 Pressure sensor   Bases  bittag-base-jlcpcb-v3[-dfu] – Tag base (-dfu for programming) tag-breakout-base-jlcpcb32-v1[-dfu] – Tag breakout board stlink interface    In addition, cmake files are provided for generating gerber and outline files for the following hardware:\n AccelTag-pcb – AccelTag board tagbase-jlcpcb-v3 – Tag base board MultiCharger-pcb – Tag charger board  Finally, the 3d printed tag adapter for BitTags can be generated\n multicharger-acrylic  3. Building on OS X The process for building on OS X is similar to that for Linux except that OS X applications are typically bundled into .app directories. To build these bundles, we depend upon a tool, macdeployqt, that combines the compiled (host) applications with any necessary libraries in an .app directory. The installation of Qt5 is discussed in the section on Software. In order for CMake to find macdeployqt, you must make sure that the directory qt/5.15.1/bin is included in your bash path – note that version number 5.15.1 should be changed to fit the version of Qt5 installed.\nAll of the OS X applications created by make can be packed into a singled .dmg file for distribution to other users.\ncd build_directory cpack -G DragNDrop 3. Building on Windows Unfortunately, the process for building on Windows is significantly more complicated than for other platforms. The fundamental reason for this is the lack of a coherent path mechanism, within a terminal window, for scripts to find applications. This problem is particularly acute when using the compilation tools in Visual Studio from a command line. To mitigate this problem you must:\n Use the powershell window configured for Visual Studio Modify the powershell path environment variable Use vcpkg to manage the various software libaries  Powershell integration with visual studio is described here and here. Briefly, when Visual Studio 2019 is installed, a “Developer PowerShell for VS 2019” is made available in the Start menu. This PowerShell instance has many of the required path variables installed.\nIn addition, the path environment variables should be modified (described here) to include the paths to the various tools used in the build process (CMake, STM32_Programmer_CLI,FMPP, etc.)\nFinally, we use vcpkg to manage the various software libraries (described in the Software section).\nWith all that accomplished, the process of building becomes\nmkdir build_directory cd build_directory cmake -G \"Visual Studio 16 2019\" -Ax64 -DVCPKG_TARGET_TRIPLET=\"x64-windows-static\" -DCMAKE_TOOLCHAIN_FILE=\"path_to/vcpkg/scripts/buildsystems/vcpkg.cmake\" path_to_nanotag_repo cmake --build . --config Release The differences with Linux are, lines 3 and 4. In line 3, CMake is directed to configure the build for Visual Studio 2019 using the toolchain file from vcpkg and for a static x64 target. Line 4 performs the actual build (this configuration does not use make files).\nIn addition to a Release configuration, one can build a Debug configuration:\ncmake --build . --config Debug One can build and download tags as in\ncmake --build . --target [BitTagv6|BitTagv5|NucleoTag] cmake --build . --target BitTagv6-download Furthermore, one can erase tags as in\ncmake --build . --target BitTagv6-erase. Finally, one can build and download baseboard firmware:\ncmake --build . --target bittag-base-jlcpcb-v3 cmake --build . --target bittag-base-jlcpcb-v3-dfu building with OS X Use the “brew” version of QT because it links statically.\nMake sure to add /usr/local/Cellar/qt/5.15.1/bin (or current version) to your path so that the various find_program tools work (esp macdeployqt)\nBuilding the dmg file for system toos\ncpack -G DragNDrop\n2. Embedded Software Compiling and downloading embedded software requires several additional tools.\n gnuarm fmpp gnu make  The primary toolchain for the stm32 processors used in all our devices is the free gunarm toolchain. ChibiOS designs additionally require the freemarker-based file preprocessor (a java application). On Windows it will also be necessary to install gnu make (for example from chocolaty).\nWe utilize the STMicroelectronics stm32cube programmer to program and erase both tags and baseboards.\nProgramming with STM32Cube Programmer The cmake configuration files include rules to download and erase tags and bases. It is also possible to use the programmer from the command line. The following illustrates this process on Windows.\n~/Software/STM32CubeProgrammer/bin/STM32_Programmer_CLI.exe -c port=SWD mode=UR -d ch.elf -v -g 0x08000000  port=SWD driver mode=UR – attach under reset -g 0x08000000 – execute program after completion -v verify -vb 3 verbose logging (for debugging)  DFU for base boards The base boards do not have a arm debug interface and hence are programmed using DFU mode. To put the device in DFU mode, plug in USB while holding down the dfu button on the device.\nMake sure a device is in dfu mode\nSTM32_Programmer_CLI.exe -l usb To program from command line\n ~/Software/STM32CubeProgrammer/bin/STM32_Programmer_CLI -c port=usb1 -d build/ch.elf ","categories":"","description":"Installing and building software and hardware design files\n","excerpt":"Installing and building software and hardware design files\n","ref":"/docs/building/","tags":"","title":"Installation"},{"body":"Applicable Licenses The code in this repository builds upon the contributions of a number of other projects. Unless otherwise stated, or unless other license terms dominate, the software developed for this project is distributed under a BSD 3-clause license.\nFor example, the Qt based applications were developed using the Qt GPL terms, therefore those applications honor the terms of that licence. In contrast, the command-line applications rely on libraries whose license terms that do not take precedence over the project license.\nA Request\nWe request that any use of this work or derivatives of this work in scientific research appropriately cite our contributions in any publications.\nhow to cite:\n1. Host Software We consider the host software in three categories – the tag and monitor libraries, and the various applications. The tag/monitor libraries build upon libraries that are compatible with our project license.\n1.1 Tag/Monitor Libraries The monitor library provides connectivity, via USB, to the baseboard which emulates an stlink device. The monitor library utilizes libusb which is licensed under the lesser gpl 2 licence. In addition, the monitor library code utilizes constants and ideas from stlink-org which is licensed under a BSD 3-clause licence.\nThe tag library uses code built with the Google ProtoBuf compiler and linked to the Google ProtoBuf libraries that code is licensed under a Google License.\n1.2 Command-line Applications The command-line applications use the monitor and tag libraries; any other code is licensed under the default terms described above.\n1.3 Qt Based Applications The two Qt based applications were developed under the Qt open source license terms and hence the use of Qt libraries is covered by the LGPLv3 license. ** how to get QT source code **\nThe BitTag data visualization application (btviz) uses the QCustomPlot library and hence is licensed under GPLv3. The creator of QCustomPlot offers commercial licenses. In this case, the Qt open source license terms apply to the use of Qt libraries, and our project license applies to the remaining source code.\n2. Embedded Software 2.1 Base Boards 2.2 Tags 3. Hardware ","categories":"","description":"","excerpt":"Applicable Licenses The code in this repository builds upon the …","ref":"/docs/license/","tags":"","title":"Licenses"},{"body":"This material is based upon work supported by the National Science Foundation Grant Number 1644717. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation.\n","categories":"","description":"Acknowledgements for funding and research contributions\n","excerpt":"Acknowledgements for funding and research contributions\n","ref":"/docs/acknowledgement/","tags":"","title":"Acknowledgement"},{"body":"Contact Information Geoffrey Brown geobrown@indiana.edu\n","categories":"","description":"","excerpt":"Contact Information Geoffrey Brown geobrown@indiana.edu\n","ref":"/docs/contact/","tags":"","title":"Contacts"},{"body":"Rapid improvements in low-power, inexpensive, movement and environmental sensors has sparked a revolution in animal behavior research by enabling the creation of novel data-loggers (tags) that can capture fine-grained activity and location data over many months. Nevertheless, development of tags that are suitable for use with small species of birds remains challenging because of the extreme weight (and hence energy) constraints.   Dark-eyed JuncoJocelyn Anderson \n    This website documents the use, design, and fabrication of NanoLoggers which are custom tags below the mass and power budgets of most low-energy devices – $1g$ and $1\\mu W$, respectively – that can collect continuous data for up to a year. The tags we present are archival, which means that the data they collect can only be downloaded by retrieving the tags. Tags with telemetry interfaces are not generally practical for long-lived data collection at the scale we describe.   Example Tag     Our biology partners study the behavior and ecology of dark-eyed juncos ($20-25g$), pine siskins ($12-18g$), great tits ($16-21g$), and robins. (Citation: , 2019(2019). Retrieved from  https://www.allaboutbirds.org )   (2019)  (2019). Retrieved from  https://www.allaboutbirds.org     ","categories":"","description":"","excerpt":"Rapid improvements in low-power, inexpensive, movement and …","ref":"/","tags":"","title":"About"},{"body":"Tools and Supplies A variety of tools and supplies are needed to\n Prepare tags for flight Assemble tags Assembly bases and chargers  Most users will be concerned only with (1)\nPreparing Tags For Flight For a guide to preparing tags for flight see [section]. This guide, by Jiawei Chen and Tim Greives, while written for the BitTag, applies to other tags as well.\nAssuming that the tags are fully assembled, the only supplies and tools required are\n3mm Kapton (polymide) Tape: Kapton tape is widely use for insulation on electronics and holds up well under challenging conditions. For tag flight preparation, a rectangle 3mm by 4mm is ideal for covering the test points on a tag used by the base and chargers for communication.\n Ceramic Tweezers: While not strictly necessary, ceramic tweezers are ideal for manipulating the small rectangles of tape used to insulate the tag test points. These can be obtained inexpensively from Amazon.\n Small Scissors: A pair of small, sharp scissors is essential for tag preparation.\n **Tape Application Sticks** (4mm wooden coffee stirrers) Wooden coffee stirrers are ideal for smoothing insulating tape while minimizing the potential for damage.  Harness Material (elastic cord) 1mm (or smaller) elastic cord is needed for building harnesses. See leg harness section for directions.\n Assembling Tags The process of assembling tags includes soldering on batteries and applying insulation. There are two types of insulation used – the batteries are covered in 1mil kapton tape and, after soldering, the entire assembly is dipped into a urethane coating.\nSoldering Station for the fine level assembly required it essential to use a high quality temperature controlled soldering iron with a fine-pitched tip. In our lab we use the Hakko FX-951 soldering station with fine conical tips (e.g. 0.2mm T15-IL) for most work\n Boom Microscope A microscope is not required for assembling tags, but is definitely helpful. Ideally, this should be a microscope with zoom capability.\n Optivisor An optivisor is essential for the fine work necessary to assemble tags. Be careful to request the ones with glass lenses !\n Solder A small diameter (e.g. 0.02 inch), leaded, flux core solder is essential.\n Flux in pen form is especially useful for soldering small components such as batteries.\n ** Flux Remover** After soldering, all components should be carefully cleaned with flux remover.\n Cotton Swabs We use fine cotton swabs for this purpose.\n Kapton Tape Various widths of 1mil kapton tape are required for wrapping batteries (1/4\", 3/8\", 1/2\") depending upon battery diameter. Ideally the tape should be slightly wider than the battery.\n Masking Taper During the coating process we use 6mm Scotch Masking Tape 233 to protect the contacts from the coating. This is an automotive paint masking tape that bonds well, removes easily, and is compatible with various solvents.\n Floral Wire We use 24 gauge floral wire to make disposable hangers for the tags for use during the coating process. This is soft, easily bendable wire.\n xacto knife An x-acto #1 is essential for cleaning excess coating material after coating tags.\n Pin Vise A pin vise with 1-1.1 mm drill is needed for cleaning the tag holes after coating\n Diagonal Cutters A small pair of diagonal cutters is needed for forming the tag hangers for coating.\n Needle Nose Pliers A small pair of needle nose pliers is needed for forming hangers.\n MG 4223 We use MG Chemicals 4223 urethane coating for insulating the tags. This is available in a 55ml bottle. In practice we immerse the tags (with batteries) directly in the coating and hang them to dry.\n Assembly of Bases and Chargers The assembly of bases and chargers requires the soldering tools described above (soldering station, microscope, solder, flux, flux remover). In addition it is helpful to have tools to hold the various boards during assembly.\nToolour magnetic fixture tower Magnetic fixtures such as this are useful for holding boards during soldering\n","categories":"","description":"Tools and Supplies","excerpt":"Tools and Supplies","ref":"/docs/userguides/fabrication/tools/","tags":"","title":"Tools"}]